# -*- coding: utf-8 -*-
# code generated by Prisma. DO NOT EDIT.
# pyright: reportUnusedImport=false
# fmt: off

# global imports for type checking
from builtins import bool as _bool
from builtins import int as _int
from builtins import float as _float
from builtins import str as _str
import sys
import decimal
import datetime
from typing import (
    TYPE_CHECKING,
    Optional,
    Iterable,
    Iterator,
    Sequence,
    Callable,
    ClassVar,
    NoReturn,
    TypeVar,
    Generic,
    Mapping,
    Tuple,
    Union,
    List,
    Dict,
    Type,
    Any,
    Set,
    overload,
    cast,
)
from typing_extensions import TypedDict, Literal


LiteralString = str
# -- template types.py.jinja --
from typing import TypeVar

import httpx
from . import _types
from .utils import _NoneType



# TODO: filters with aggregates should have their own recursive fields
# TODO: cleanup whitespace control
# TODO: add an argument to signify that the last iteration should be skipped


SortMode = _types.SortMode
SortOrder = _types.SortOrder

MetricsFormat = _types.MetricsFormat

DatasourceOverride = _types.DatasourceOverride
HttpConfig = _types.HttpConfig


# types that can be serialized to json by our query builder
Serializable = Union[
    None,
    bool,
    float,
    int,
    str,
    datetime.datetime,
    List[Any],
    Dict[None, Any],
    Dict[bool, Any],
    Dict[float, Any],
    Dict[int, Any],
    Dict[str, Any],
]


    

StringFilter = TypedDict(
    'StringFilter',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive1'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive1 = TypedDict(
    'StringFilterRecursive1',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive2'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive2 = TypedDict(
    'StringFilterRecursive2',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive3'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive3 = TypedDict(
    'StringFilterRecursive3',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
        'not': Union[str, 'StringFilterRecursive4'],
        'mode': SortMode,
    },
    total=False,
)


StringFilterRecursive4 = TypedDict(
    'StringFilterRecursive4',
    {
        'equals': str,
        'not_in': List[str],
        'lt': str,
        'lte': str,
        'gt': str,
        'gte': str,
        'contains': str,
        'startswith': str,
        'endswith': str,
        'in': List[str],
                'mode': SortMode,
    },
    total=False,
)


class StringWithAggregatesFilter(StringFilter, total=False):
    _max: 'StringFilter'
    _min: 'StringFilter'
    _sum: 'StringFilter'
    _avg: 'StringFilter'
    _count: 'IntFilter'


    

DateTimeFilter = TypedDict(
    'DateTimeFilter',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive1'],
    },
    total=False,
)


DateTimeFilterRecursive1 = TypedDict(
    'DateTimeFilterRecursive1',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive2'],
    },
    total=False,
)


DateTimeFilterRecursive2 = TypedDict(
    'DateTimeFilterRecursive2',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive3'],
    },
    total=False,
)


DateTimeFilterRecursive3 = TypedDict(
    'DateTimeFilterRecursive3',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
        'not': Union[datetime.datetime, 'DateTimeFilterRecursive4'],
    },
    total=False,
)


DateTimeFilterRecursive4 = TypedDict(
    'DateTimeFilterRecursive4',
    {
        'equals': datetime.datetime,
        'not_in': List[datetime.datetime],
        'lt': datetime.datetime,
        'lte': datetime.datetime,
        'gt': datetime.datetime,
        'gte': datetime.datetime,
        'in': List[datetime.datetime],
            },
    total=False,
)


class DateTimeWithAggregatesFilter(DateTimeFilter, total=False):
    _max: 'DateTimeFilter'
    _min: 'DateTimeFilter'
    _sum: 'DateTimeFilter'
    _avg: 'DateTimeFilter'
    _count: 'IntFilter'


    

BooleanFilter = TypedDict(
    'BooleanFilter',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive1'],
    },
    total=False,
)


BooleanFilterRecursive1 = TypedDict(
    'BooleanFilterRecursive1',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive2'],
    },
    total=False,
)


BooleanFilterRecursive2 = TypedDict(
    'BooleanFilterRecursive2',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive3'],
    },
    total=False,
)


BooleanFilterRecursive3 = TypedDict(
    'BooleanFilterRecursive3',
    {
        'equals': bool,
        'not': Union[bool, 'BooleanFilterRecursive4'],
    },
    total=False,
)


BooleanFilterRecursive4 = TypedDict(
    'BooleanFilterRecursive4',
    {
        'equals': bool,
            },
    total=False,
)


class BooleanWithAggregatesFilter(BooleanFilter, total=False):
    _max: 'BooleanFilter'
    _min: 'BooleanFilter'
    _sum: 'BooleanFilter'
    _avg: 'BooleanFilter'
    _count: 'IntFilter'


    

IntFilter = TypedDict(
    'IntFilter',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive1'],
    },
    total=False,
)


IntFilterRecursive1 = TypedDict(
    'IntFilterRecursive1',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive2'],
    },
    total=False,
)


IntFilterRecursive2 = TypedDict(
    'IntFilterRecursive2',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive3'],
    },
    total=False,
)


IntFilterRecursive3 = TypedDict(
    'IntFilterRecursive3',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
        'not': Union[int, 'IntFilterRecursive4'],
    },
    total=False,
)


IntFilterRecursive4 = TypedDict(
    'IntFilterRecursive4',
    {
        'equals': int,
        'not_in': List[int],
        'lt': int,
        'lte': int,
        'gt': int,
        'gte': int,
        'in': List[int],
            },
    total=False,
)


class IntWithAggregatesFilter(IntFilter, total=False):
    _max: 'IntFilter'
    _min: 'IntFilter'
    _sum: 'IntFilter'
    _avg: 'IntFilter'
    _count: 'IntFilter'


BigIntFilter = IntFilter
BigIntWithAggregatesFilter = IntWithAggregatesFilter
    

FloatFilter = TypedDict(
    'FloatFilter',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive1'],
    },
    total=False,
)


FloatFilterRecursive1 = TypedDict(
    'FloatFilterRecursive1',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive2'],
    },
    total=False,
)


FloatFilterRecursive2 = TypedDict(
    'FloatFilterRecursive2',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive3'],
    },
    total=False,
)


FloatFilterRecursive3 = TypedDict(
    'FloatFilterRecursive3',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
        'not': Union[float, 'FloatFilterRecursive4'],
    },
    total=False,
)


FloatFilterRecursive4 = TypedDict(
    'FloatFilterRecursive4',
    {
        'equals': float,
        'not_in': List[float],
        'lt': float,
        'lte': float,
        'gt': float,
        'gte': float,
        'in': List[float],
            },
    total=False,
)


class FloatWithAggregatesFilter(FloatFilter, total=False):
    _max: 'FloatFilter'
    _min: 'FloatFilter'
    _sum: 'FloatFilter'
    _avg: 'FloatFilter'
    _count: 'IntFilter'


    

BytesFilter = TypedDict(
    'BytesFilter',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive1'],
    },
    total=False,
)


BytesFilterRecursive1 = TypedDict(
    'BytesFilterRecursive1',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive2'],
    },
    total=False,
)


BytesFilterRecursive2 = TypedDict(
    'BytesFilterRecursive2',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive3'],
    },
    total=False,
)


BytesFilterRecursive3 = TypedDict(
    'BytesFilterRecursive3',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
        'not': Union['fields.Base64', 'BytesFilterRecursive4'],
    },
    total=False,
)


BytesFilterRecursive4 = TypedDict(
    'BytesFilterRecursive4',
    {
        'equals': 'fields.Base64',
        'in': List['fields.Base64'],
        'not_in': List['fields.Base64'],
            },
    total=False,
)


class BytesWithAggregatesFilter(BytesFilter, total=False):
    _max: 'BytesFilter'
    _min: 'BytesFilter'
    _sum: 'BytesFilter'
    _avg: 'BytesFilter'
    _count: 'IntFilter'


# TODO: preview feature for improving JSON filtering
JsonFilter = TypedDict(
    'JsonFilter',
    {
        'equals': 'fields.Json',
        'not': 'fields.Json',
    },
    total=False,
)


class JsonWithAggregatesFilter(JsonFilter, total=False):
    _max: 'JsonFilter'
    _min: 'JsonFilter'
    _sum: 'JsonFilter'
    _avg: 'JsonFilter'
    _count: 'IntFilter'


    

DecimalFilter = TypedDict(
    'DecimalFilter',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive1'],
    },
    total=False,
)


DecimalFilterRecursive1 = TypedDict(
    'DecimalFilterRecursive1',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive2'],
    },
    total=False,
)


DecimalFilterRecursive2 = TypedDict(
    'DecimalFilterRecursive2',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive3'],
    },
    total=False,
)


DecimalFilterRecursive3 = TypedDict(
    'DecimalFilterRecursive3',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
        'not': Union[decimal.Decimal, 'DecimalFilterRecursive4'],
    },
    total=False,
)


DecimalFilterRecursive4 = TypedDict(
    'DecimalFilterRecursive4',
    {
        'equals': decimal.Decimal,
        'not_in': List[decimal.Decimal],
        'lt': decimal.Decimal,
        'lte': decimal.Decimal,
        'gt': decimal.Decimal,
        'gte': decimal.Decimal,
        'in': List[decimal.Decimal],
            },
    total=False,
)


class DecimalWithAggregatesFilter(StringFilter, total=False):
    _max: 'DecimalFilter'
    _min: 'DecimalFilter'
    _sum: 'DecimalFilter'
    _avg: 'DecimalFilter'
    _count: 'IntFilter'


class _FloatSetInput(TypedDict):
    set: float


class _FloatDivideInput(TypedDict):
    divide: float


class _FloatMultiplyInput(TypedDict):
    multiply: float


class _FloatIncrementInput(TypedDict):
    increment: float


class _FloatDecrementInput(TypedDict):
    decrement: float


class _IntSetInput(TypedDict):
    set: int


class _IntDivideInput(TypedDict):
    divide: int


class _IntMultiplyInput(TypedDict):
    multiply: int


class _IntIncrementInput(TypedDict):
    increment: int


class _IntDecrementInput(TypedDict):
    decrement: int


AtomicFloatInput = Union[
    _FloatSetInput,
    _FloatDivideInput,
    _FloatMultiplyInput,
    _FloatIncrementInput,
    _FloatDecrementInput,
]
AtomicIntInput = Union[
    _IntSetInput,
    _IntDivideInput,
    _IntMultiplyInput,
    _IntIncrementInput,
    _IntDecrementInput,
]
AtomicBigIntInput = AtomicIntInput

class _StringListFilterEqualsInput(TypedDict):
    equals: Optional[List[_str]]


class _StringListFilterHasInput(TypedDict):
    has: _str


class _StringListFilterHasEveryInput(TypedDict):
    has_every: List[_str]


class _StringListFilterHasSomeInput(TypedDict):
    has_some: List[_str]


class _StringListFilterIsEmptyInput(TypedDict):
    is_empty: bool


StringListFilter = Union[
    _StringListFilterHasInput,
    _StringListFilterEqualsInput,
    _StringListFilterHasSomeInput,
    _StringListFilterIsEmptyInput,
    _StringListFilterHasEveryInput,
]


class _StringListUpdateSet(TypedDict):
    set: List[_str]


class _StringListUpdatePush(TypedDict):
    push: List[_str]


StringListUpdate = Union[
    List[_str],
    _StringListUpdateSet,
    _StringListUpdatePush,
]

class _BytesListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Base64']]


class _BytesListFilterHasInput(TypedDict):
    has: 'fields.Base64'


class _BytesListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Base64']


class _BytesListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Base64']


class _BytesListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BytesListFilter = Union[
    _BytesListFilterHasInput,
    _BytesListFilterEqualsInput,
    _BytesListFilterHasSomeInput,
    _BytesListFilterIsEmptyInput,
    _BytesListFilterHasEveryInput,
]


class _BytesListUpdateSet(TypedDict):
    set: List['fields.Base64']


class _BytesListUpdatePush(TypedDict):
    push: List['fields.Base64']


BytesListUpdate = Union[
    List['fields.Base64'],
    _BytesListUpdateSet,
    _BytesListUpdatePush,
]

class _DateTimeListFilterEqualsInput(TypedDict):
    equals: Optional[List[datetime.datetime]]


class _DateTimeListFilterHasInput(TypedDict):
    has: datetime.datetime


class _DateTimeListFilterHasEveryInput(TypedDict):
    has_every: List[datetime.datetime]


class _DateTimeListFilterHasSomeInput(TypedDict):
    has_some: List[datetime.datetime]


class _DateTimeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DateTimeListFilter = Union[
    _DateTimeListFilterHasInput,
    _DateTimeListFilterEqualsInput,
    _DateTimeListFilterHasSomeInput,
    _DateTimeListFilterIsEmptyInput,
    _DateTimeListFilterHasEveryInput,
]


class _DateTimeListUpdateSet(TypedDict):
    set: List[datetime.datetime]


class _DateTimeListUpdatePush(TypedDict):
    push: List[datetime.datetime]


DateTimeListUpdate = Union[
    List[datetime.datetime],
    _DateTimeListUpdateSet,
    _DateTimeListUpdatePush,
]

class _BooleanListFilterEqualsInput(TypedDict):
    equals: Optional[List[_bool]]


class _BooleanListFilterHasInput(TypedDict):
    has: _bool


class _BooleanListFilterHasEveryInput(TypedDict):
    has_every: List[_bool]


class _BooleanListFilterHasSomeInput(TypedDict):
    has_some: List[_bool]


class _BooleanListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BooleanListFilter = Union[
    _BooleanListFilterHasInput,
    _BooleanListFilterEqualsInput,
    _BooleanListFilterHasSomeInput,
    _BooleanListFilterIsEmptyInput,
    _BooleanListFilterHasEveryInput,
]


class _BooleanListUpdateSet(TypedDict):
    set: List[_bool]


class _BooleanListUpdatePush(TypedDict):
    push: List[_bool]


BooleanListUpdate = Union[
    List[_bool],
    _BooleanListUpdateSet,
    _BooleanListUpdatePush,
]

class _IntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _IntListFilterHasInput(TypedDict):
    has: _int


class _IntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _IntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _IntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


IntListFilter = Union[
    _IntListFilterHasInput,
    _IntListFilterEqualsInput,
    _IntListFilterHasSomeInput,
    _IntListFilterIsEmptyInput,
    _IntListFilterHasEveryInput,
]


class _IntListUpdateSet(TypedDict):
    set: List[_int]


class _IntListUpdatePush(TypedDict):
    push: List[_int]


IntListUpdate = Union[
    List[_int],
    _IntListUpdateSet,
    _IntListUpdatePush,
]

class _BigIntListFilterEqualsInput(TypedDict):
    equals: Optional[List[_int]]


class _BigIntListFilterHasInput(TypedDict):
    has: _int


class _BigIntListFilterHasEveryInput(TypedDict):
    has_every: List[_int]


class _BigIntListFilterHasSomeInput(TypedDict):
    has_some: List[_int]


class _BigIntListFilterIsEmptyInput(TypedDict):
    is_empty: bool


BigIntListFilter = Union[
    _BigIntListFilterHasInput,
    _BigIntListFilterEqualsInput,
    _BigIntListFilterHasSomeInput,
    _BigIntListFilterIsEmptyInput,
    _BigIntListFilterHasEveryInput,
]


class _BigIntListUpdateSet(TypedDict):
    set: List[_int]


class _BigIntListUpdatePush(TypedDict):
    push: List[_int]


BigIntListUpdate = Union[
    List[_int],
    _BigIntListUpdateSet,
    _BigIntListUpdatePush,
]

class _FloatListFilterEqualsInput(TypedDict):
    equals: Optional[List[_float]]


class _FloatListFilterHasInput(TypedDict):
    has: _float


class _FloatListFilterHasEveryInput(TypedDict):
    has_every: List[_float]


class _FloatListFilterHasSomeInput(TypedDict):
    has_some: List[_float]


class _FloatListFilterIsEmptyInput(TypedDict):
    is_empty: bool


FloatListFilter = Union[
    _FloatListFilterHasInput,
    _FloatListFilterEqualsInput,
    _FloatListFilterHasSomeInput,
    _FloatListFilterIsEmptyInput,
    _FloatListFilterHasEveryInput,
]


class _FloatListUpdateSet(TypedDict):
    set: List[_float]


class _FloatListUpdatePush(TypedDict):
    push: List[_float]


FloatListUpdate = Union[
    List[_float],
    _FloatListUpdateSet,
    _FloatListUpdatePush,
]

class _JsonListFilterEqualsInput(TypedDict):
    equals: Optional[List['fields.Json']]


class _JsonListFilterHasInput(TypedDict):
    has: 'fields.Json'


class _JsonListFilterHasEveryInput(TypedDict):
    has_every: List['fields.Json']


class _JsonListFilterHasSomeInput(TypedDict):
    has_some: List['fields.Json']


class _JsonListFilterIsEmptyInput(TypedDict):
    is_empty: bool


JsonListFilter = Union[
    _JsonListFilterHasInput,
    _JsonListFilterEqualsInput,
    _JsonListFilterHasSomeInput,
    _JsonListFilterIsEmptyInput,
    _JsonListFilterHasEveryInput,
]


class _JsonListUpdateSet(TypedDict):
    set: List['fields.Json']


class _JsonListUpdatePush(TypedDict):
    push: List['fields.Json']


JsonListUpdate = Union[
    List['fields.Json'],
    _JsonListUpdateSet,
    _JsonListUpdatePush,
]

class _DecimalListFilterEqualsInput(TypedDict):
    equals: Optional[List[decimal.Decimal]]


class _DecimalListFilterHasInput(TypedDict):
    has: decimal.Decimal


class _DecimalListFilterHasEveryInput(TypedDict):
    has_every: List[decimal.Decimal]


class _DecimalListFilterHasSomeInput(TypedDict):
    has_some: List[decimal.Decimal]


class _DecimalListFilterIsEmptyInput(TypedDict):
    is_empty: bool


DecimalListFilter = Union[
    _DecimalListFilterHasInput,
    _DecimalListFilterEqualsInput,
    _DecimalListFilterHasSomeInput,
    _DecimalListFilterIsEmptyInput,
    _DecimalListFilterHasEveryInput,
]


class _DecimalListUpdateSet(TypedDict):
    set: List[decimal.Decimal]


class _DecimalListUpdatePush(TypedDict):
    push: List[decimal.Decimal]


DecimalListUpdate = Union[
    List[decimal.Decimal],
    _DecimalListUpdateSet,
    _DecimalListUpdatePush,
]

class _enumQtypeListFilterEqualsInput(TypedDict):
    equals: Optional[List['enums.enumQtype']]


class _enumQtypeListFilterHasInput(TypedDict):
    has: 'enums.enumQtype'


class _enumQtypeListFilterHasEveryInput(TypedDict):
    has_every: List['enums.enumQtype']


class _enumQtypeListFilterHasSomeInput(TypedDict):
    has_some: List['enums.enumQtype']


class _enumQtypeListFilterIsEmptyInput(TypedDict):
    is_empty: bool


enumQtypeListFilter = Union[
    _enumQtypeListFilterHasInput,
    _enumQtypeListFilterEqualsInput,
    _enumQtypeListFilterHasSomeInput,
    _enumQtypeListFilterIsEmptyInput,
    _enumQtypeListFilterHasEveryInput,
]


class _enumQtypeListUpdateSet(TypedDict):
    set: List['enums.enumQtype']


class _enumQtypeListUpdatePush(TypedDict):
    push: List['enums.enumQtype']


enumQtypeListUpdate = Union[
    List['enums.enumQtype'],
    _enumQtypeListUpdateSet,
    _enumQtypeListUpdatePush,
]


# Survey types

class SurveyOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Survey create method"""
    SurveyID: _int
    questions: 'QuestionCreateManyNestedWithoutRelationsInput'


class SurveyCreateInput(SurveyOptionalCreateInput):
    """Required arguments to the Survey create method"""
    PersonID: _int
    Timestamp: datetime.datetime
    Title: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SurveyOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Survey create method, without relations"""
    SurveyID: _int


class SurveyCreateWithoutRelationsInput(SurveyOptionalCreateWithoutRelationsInput):
    """Required arguments to the Survey create method, without relations"""
    PersonID: _int
    Timestamp: datetime.datetime
    Title: _str


class SurveyCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SurveyCreateWithoutRelationsInput'
    connect: 'SurveyWhereUniqueInput'


class SurveyCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SurveyCreateWithoutRelationsInput', List['SurveyCreateWithoutRelationsInput']]
    connect: Union['SurveyWhereUniqueInput', List['SurveyWhereUniqueInput']]


_SurveyWhereUnique_SurveyID_Input = TypedDict(
    '_SurveyWhereUnique_SurveyID_Input',
    {
        'SurveyID': '_int',
    },
    total=True
)

SurveyWhereUniqueInput = _SurveyWhereUnique_SurveyID_Input


class SurveyUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    SurveyID: Union[AtomicIntInput, _int]
    PersonID: Union[AtomicIntInput, _int]
    Timestamp: datetime.datetime
    Title: _str
    questions: 'QuestionUpdateManyWithoutRelationsInput'


class SurveyUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    SurveyID: Union[AtomicIntInput, _int]
    PersonID: Union[AtomicIntInput, _int]
    Timestamp: datetime.datetime
    Title: _str


class SurveyUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SurveyCreateWithoutRelationsInput']
    connect: List['SurveyWhereUniqueInput']
    set: List['SurveyWhereUniqueInput']
    disconnect: List['SurveyWhereUniqueInput']
    delete: List['SurveyWhereUniqueInput']

    # TODO
    # update: List['SurveyUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SurveyUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SurveyScalarWhereInput']
    # upsert: List['SurveyUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SurveyCreateOrConnectWithoutRelationsInput']


class SurveyUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SurveyCreateWithoutRelationsInput'
    connect: 'SurveyWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SurveyUpdateInput'
    # upsert: 'SurveyUpsertWithoutRelationsInput'
    # connectOrCreate: 'SurveyCreateOrConnectWithoutRelationsInput'


class SurveyUpsertInput(TypedDict):
    create: 'SurveyCreateInput'
    update: 'SurveyUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Survey_SurveyID_OrderByInput = TypedDict(
    '_Survey_SurveyID_OrderByInput',
    {
        'SurveyID': 'SortOrder',
    },
    total=True
)

_Survey_PersonID_OrderByInput = TypedDict(
    '_Survey_PersonID_OrderByInput',
    {
        'PersonID': 'SortOrder',
    },
    total=True
)

_Survey_Timestamp_OrderByInput = TypedDict(
    '_Survey_Timestamp_OrderByInput',
    {
        'Timestamp': 'SortOrder',
    },
    total=True
)

_Survey_Title_OrderByInput = TypedDict(
    '_Survey_Title_OrderByInput',
    {
        'Title': 'SortOrder',
    },
    total=True
)

SurveyOrderByInput = Union[
    '_Survey_SurveyID_OrderByInput',
    '_Survey_PersonID_OrderByInput',
    '_Survey_Timestamp_OrderByInput',
    '_Survey_Title_OrderByInput',
]



# recursive Survey types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SurveyRelationFilter = TypedDict(
    'SurveyRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SurveyListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SurveyInclude(TypedDict, total=False):
    """Survey relational arguments"""
    questions: Union[bool, 'FindManyQuestionArgsFromSurvey']


    

class SurveyIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    questions: Union[bool, 'FindManyQuestionArgsFromSurveyRecursive1']


class SurveyIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    questions: Union[bool, 'FindManyQuestionArgsFromSurveyRecursive2']


class SurveyIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    questions: Union[bool, 'FindManyQuestionArgsFromSurveyRecursive3']


class SurveyIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    questions: Union[bool, 'FindManyQuestionArgsFromSurveyRecursive4']


class SurveyIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class SurveyArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManySurveyArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    survey: Union[bool, 'SurveyArgsFromSurveyRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSurveyRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive1']


class QuestionIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    survey: Union[bool, 'SurveyArgsFromSurveyRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSurveyRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive2']


class QuestionIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    survey: Union[bool, 'SurveyArgsFromSurveyRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSurveyRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive3']


class QuestionIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    survey: Union[bool, 'SurveyArgsFromSurveyRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSurveyRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSurveyRecursive4']


class QuestionIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class QuestionArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManyQuestionArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromSurveyRecursive1']


class OptionalAnswerIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromSurveyRecursive2']


class OptionalAnswerIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromSurveyRecursive3']


class OptionalAnswerIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromSurveyRecursive4']


class OptionalAnswerIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class OptionalAnswerArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManyOptionalAnswerArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive1']


class UserAnswerIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive2']


class UserAnswerIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive3']


class UserAnswerIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    question: Union[bool, 'QuestionArgsFromSurveyRecursive4']


class UserAnswerIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class UserAnswerArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManyUserAnswerArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    settlement: Union[bool, 'SettlementArgsFromSurveyRecursive1']


class UserAnswerNewIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    settlement: Union[bool, 'SettlementArgsFromSurveyRecursive2']


class UserAnswerNewIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    settlement: Union[bool, 'SettlementArgsFromSurveyRecursive3']


class UserAnswerNewIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    settlement: Union[bool, 'SettlementArgsFromSurveyRecursive4']


class UserAnswerNewIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class UserAnswerNewArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManyUserAnswerNewArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromSurvey(TypedDict, total=False):
    """Relational arguments for Survey"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSurveyRecursive1']


class SettlementIncludeFromSurveyRecursive1(TypedDict, total=False):
    """Relational arguments for Survey"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSurveyRecursive2']


class SettlementIncludeFromSurveyRecursive2(TypedDict, total=False):
    """Relational arguments for Survey"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSurveyRecursive3']


class SettlementIncludeFromSurveyRecursive3(TypedDict, total=False):
    """Relational arguments for Survey"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSurveyRecursive4']


class SettlementIncludeFromSurveyRecursive4(TypedDict, total=False):
    """Relational arguments for Survey"""

    

class SettlementArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    
    

class FindManySettlementArgsFromSurvey(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromSurveyRecursive1(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromSurveyRecursive2(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromSurveyRecursive3(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromSurveyRecursive4(TypedDict, total=False):
    """Arguments for Survey"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManySurveyArgs = FindManySurveyArgsFromSurvey
FindFirstSurveyArgs = FindManySurveyArgsFromSurvey


    

class SurveyWhereInput(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntFilter']
    PersonID: Union[_int, 'types.IntFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    Title: Union[_str, 'types.StringFilter']
    questions: 'QuestionListRelationFilter'

    # should be noted that AND and NOT should be Union['SurveyWhereInputRecursive1', List['SurveyWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SurveyWhereInputRecursive1']
    OR: List['SurveyWhereInputRecursive1']
    NOT: List['SurveyWhereInputRecursive1']


class SurveyWhereInputRecursive1(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntFilter']
    PersonID: Union[_int, 'types.IntFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    Title: Union[_str, 'types.StringFilter']
    questions: 'QuestionListRelationFilter'

    # should be noted that AND and NOT should be Union['SurveyWhereInputRecursive2', List['SurveyWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SurveyWhereInputRecursive2']
    OR: List['SurveyWhereInputRecursive2']
    NOT: List['SurveyWhereInputRecursive2']


class SurveyWhereInputRecursive2(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntFilter']
    PersonID: Union[_int, 'types.IntFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    Title: Union[_str, 'types.StringFilter']
    questions: 'QuestionListRelationFilter'

    # should be noted that AND and NOT should be Union['SurveyWhereInputRecursive3', List['SurveyWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SurveyWhereInputRecursive3']
    OR: List['SurveyWhereInputRecursive3']
    NOT: List['SurveyWhereInputRecursive3']


class SurveyWhereInputRecursive3(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntFilter']
    PersonID: Union[_int, 'types.IntFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    Title: Union[_str, 'types.StringFilter']
    questions: 'QuestionListRelationFilter'

    # should be noted that AND and NOT should be Union['SurveyWhereInputRecursive4', List['SurveyWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SurveyWhereInputRecursive4']
    OR: List['SurveyWhereInputRecursive4']
    NOT: List['SurveyWhereInputRecursive4']


class SurveyWhereInputRecursive4(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntFilter']
    PersonID: Union[_int, 'types.IntFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    Title: Union[_str, 'types.StringFilter']
    questions: 'QuestionListRelationFilter'



# aggregate Survey types


    

class SurveyScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SurveyScalarWhereWithAggregatesInputRecursive1']
    OR: List['SurveyScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SurveyScalarWhereWithAggregatesInputRecursive1']


class SurveyScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SurveyScalarWhereWithAggregatesInputRecursive2']
    OR: List['SurveyScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SurveyScalarWhereWithAggregatesInputRecursive2']


class SurveyScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SurveyScalarWhereWithAggregatesInputRecursive3']
    OR: List['SurveyScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SurveyScalarWhereWithAggregatesInputRecursive3']


class SurveyScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SurveyScalarWhereWithAggregatesInputRecursive4']
    OR: List['SurveyScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SurveyScalarWhereWithAggregatesInputRecursive4']


class SurveyScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Survey arguments for searching"""
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']
    Title: Union[_str, 'types.StringWithAggregatesFilter']



class SurveyGroupByOutput(TypedDict, total=False):
    SurveyID: _int
    PersonID: _int
    Timestamp: datetime.datetime
    Title: _str
    _sum: 'SurveySumAggregateOutput'
    _avg: 'SurveyAvgAggregateOutput'
    _min: 'SurveyMinAggregateOutput'
    _max: 'SurveyMaxAggregateOutput'
    _count: 'SurveyCountAggregateOutput'


class SurveyAvgAggregateOutput(TypedDict, total=False):
    """Survey output for aggregating averages"""
    SurveyID: float
    PersonID: float


class SurveySumAggregateOutput(TypedDict, total=False):
    """Survey output for aggregating sums"""
    SurveyID: _int
    PersonID: _int


class SurveyScalarAggregateOutput(TypedDict, total=False):
    """Survey output including scalar fields"""
    SurveyID: _int
    PersonID: _int
    Timestamp: datetime.datetime
    Title: _str


SurveyMinAggregateOutput = SurveyScalarAggregateOutput
SurveyMaxAggregateOutput = SurveyScalarAggregateOutput


class SurveyMaxAggregateInput(TypedDict, total=False):
    """Survey input for aggregating by max"""
    SurveyID: bool
    PersonID: bool
    Timestamp: bool
    Title: bool


class SurveyMinAggregateInput(TypedDict, total=False):
    """Survey input for aggregating by min"""
    SurveyID: bool
    PersonID: bool
    Timestamp: bool
    Title: bool


class SurveyNumberAggregateInput(TypedDict, total=False):
    """Survey input for aggregating numbers"""
    SurveyID: bool
    PersonID: bool


SurveyAvgAggregateInput = SurveyNumberAggregateInput
SurveySumAggregateInput = SurveyNumberAggregateInput


SurveyCountAggregateInput = TypedDict(
    'SurveyCountAggregateInput',
    {
        'SurveyID': bool,
        'PersonID': bool,
        'Timestamp': bool,
        'Title': bool,
        '_all': bool,
    },
    total=False,
)

SurveyCountAggregateOutput = TypedDict(
    'SurveyCountAggregateOutput',
    {
        'SurveyID': int,
        'PersonID': int,
        'Timestamp': int,
        'Title': int,
        '_all': int,
    },
    total=False,
)


SurveyKeys = Literal[
    'SurveyID',
    'PersonID',
    'Timestamp',
    'Title',
    'questions',
]
SurveyScalarFieldKeys = Literal[
    'SurveyID',
    'PersonID',
    'Timestamp',
    'Title',
]
SurveyScalarFieldKeysT = TypeVar('SurveyScalarFieldKeysT', bound=SurveyScalarFieldKeys)

SurveyRelationalFieldKeys = Literal[
        'questions',
    ]

# Question types

class QuestionOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Question create method"""
    QuestionID: _int
    SurveyID: _int
    survey: 'SurveyCreateNestedWithoutRelationsInput'
    optionalAnswers: 'OptionalAnswerCreateManyNestedWithoutRelationsInput'
    userAnswers: 'UserAnswerCreateManyNestedWithoutRelationsInput'
    followingQuestions: 'OptionalAnswerCreateManyNestedWithoutRelationsInput'


class QuestionCreateInput(QuestionOptionalCreateInput):
    """Required arguments to the Question create method"""
    Type: 'enums.enumQtype'
    Text: _str
    Order: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class QuestionOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Question create method, without relations"""
    QuestionID: _int
    SurveyID: _int


class QuestionCreateWithoutRelationsInput(QuestionOptionalCreateWithoutRelationsInput):
    """Required arguments to the Question create method, without relations"""
    Type: 'enums.enumQtype'
    Text: _str
    Order: _int


class QuestionCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'QuestionCreateWithoutRelationsInput'
    connect: 'QuestionWhereUniqueInput'


class QuestionCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['QuestionCreateWithoutRelationsInput', List['QuestionCreateWithoutRelationsInput']]
    connect: Union['QuestionWhereUniqueInput', List['QuestionWhereUniqueInput']]


_QuestionWhereUnique_QuestionID_Input = TypedDict(
    '_QuestionWhereUnique_QuestionID_Input',
    {
        'QuestionID': '_int',
    },
    total=True
)

QuestionWhereUniqueInput = _QuestionWhereUnique_QuestionID_Input


class QuestionUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    QuestionID: Union[AtomicIntInput, _int]
    Type: 'enums.enumQtype'
    Text: _str
    Order: Union[AtomicIntInput, _int]
    survey: 'SurveyUpdateOneWithoutRelationsInput'
    optionalAnswers: 'OptionalAnswerUpdateManyWithoutRelationsInput'
    userAnswers: 'UserAnswerUpdateManyWithoutRelationsInput'
    followingQuestions: 'OptionalAnswerUpdateManyWithoutRelationsInput'


class QuestionUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    QuestionID: Union[AtomicIntInput, _int]
    Type: 'enums.enumQtype'
    Text: _str
    Order: Union[AtomicIntInput, _int]


class QuestionUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['QuestionCreateWithoutRelationsInput']
    connect: List['QuestionWhereUniqueInput']
    set: List['QuestionWhereUniqueInput']
    disconnect: List['QuestionWhereUniqueInput']
    delete: List['QuestionWhereUniqueInput']

    # TODO
    # update: List['QuestionUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['QuestionUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['QuestionScalarWhereInput']
    # upsert: List['QuestionUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['QuestionCreateOrConnectWithoutRelationsInput']


class QuestionUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'QuestionCreateWithoutRelationsInput'
    connect: 'QuestionWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'QuestionUpdateInput'
    # upsert: 'QuestionUpsertWithoutRelationsInput'
    # connectOrCreate: 'QuestionCreateOrConnectWithoutRelationsInput'


class QuestionUpsertInput(TypedDict):
    create: 'QuestionCreateInput'
    update: 'QuestionUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Question_QuestionID_OrderByInput = TypedDict(
    '_Question_QuestionID_OrderByInput',
    {
        'QuestionID': 'SortOrder',
    },
    total=True
)

_Question_SurveyID_OrderByInput = TypedDict(
    '_Question_SurveyID_OrderByInput',
    {
        'SurveyID': 'SortOrder',
    },
    total=True
)

_Question_Type_OrderByInput = TypedDict(
    '_Question_Type_OrderByInput',
    {
        'Type': 'SortOrder',
    },
    total=True
)

_Question_Text_OrderByInput = TypedDict(
    '_Question_Text_OrderByInput',
    {
        'Text': 'SortOrder',
    },
    total=True
)

_Question_Order_OrderByInput = TypedDict(
    '_Question_Order_OrderByInput',
    {
        'Order': 'SortOrder',
    },
    total=True
)

QuestionOrderByInput = Union[
    '_Question_QuestionID_OrderByInput',
    '_Question_SurveyID_OrderByInput',
    '_Question_Type_OrderByInput',
    '_Question_Text_OrderByInput',
    '_Question_Order_OrderByInput',
]



# recursive Question types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

QuestionRelationFilter = TypedDict(
    'QuestionRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class QuestionListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class QuestionInclude(TypedDict, total=False):
    """Question relational arguments"""
    survey: Union[bool, 'SurveyArgsFromQuestion']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromQuestion']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromQuestion']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromQuestion']


    

class SurveyIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    questions: Union[bool, 'FindManyQuestionArgsFromQuestionRecursive1']


class SurveyIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    questions: Union[bool, 'FindManyQuestionArgsFromQuestionRecursive2']


class SurveyIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    questions: Union[bool, 'FindManyQuestionArgsFromQuestionRecursive3']


class SurveyIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    questions: Union[bool, 'FindManyQuestionArgsFromQuestionRecursive4']


class SurveyIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class SurveyArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManySurveyArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    survey: Union[bool, 'SurveyArgsFromQuestionRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromQuestionRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive1']


class QuestionIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    survey: Union[bool, 'SurveyArgsFromQuestionRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromQuestionRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive2']


class QuestionIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    survey: Union[bool, 'SurveyArgsFromQuestionRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromQuestionRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive3']


class QuestionIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    survey: Union[bool, 'SurveyArgsFromQuestionRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromQuestionRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromQuestionRecursive4']


class QuestionIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class QuestionArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManyQuestionArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromQuestionRecursive1']


class OptionalAnswerIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromQuestionRecursive2']


class OptionalAnswerIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromQuestionRecursive3']


class OptionalAnswerIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromQuestionRecursive4']


class OptionalAnswerIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class OptionalAnswerArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManyOptionalAnswerArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive1']


class UserAnswerIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive2']


class UserAnswerIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive3']


class UserAnswerIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    question: Union[bool, 'QuestionArgsFromQuestionRecursive4']


class UserAnswerIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class UserAnswerArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManyUserAnswerArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    settlement: Union[bool, 'SettlementArgsFromQuestionRecursive1']


class UserAnswerNewIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    settlement: Union[bool, 'SettlementArgsFromQuestionRecursive2']


class UserAnswerNewIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    settlement: Union[bool, 'SettlementArgsFromQuestionRecursive3']


class UserAnswerNewIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    settlement: Union[bool, 'SettlementArgsFromQuestionRecursive4']


class UserAnswerNewIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class UserAnswerNewArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManyUserAnswerNewArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromQuestion(TypedDict, total=False):
    """Relational arguments for Question"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromQuestionRecursive1']


class SettlementIncludeFromQuestionRecursive1(TypedDict, total=False):
    """Relational arguments for Question"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromQuestionRecursive2']


class SettlementIncludeFromQuestionRecursive2(TypedDict, total=False):
    """Relational arguments for Question"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromQuestionRecursive3']


class SettlementIncludeFromQuestionRecursive3(TypedDict, total=False):
    """Relational arguments for Question"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromQuestionRecursive4']


class SettlementIncludeFromQuestionRecursive4(TypedDict, total=False):
    """Relational arguments for Question"""

    

class SettlementArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    
    

class FindManySettlementArgsFromQuestion(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromQuestionRecursive1(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromQuestionRecursive2(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromQuestionRecursive3(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromQuestionRecursive4(TypedDict, total=False):
    """Arguments for Question"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManyQuestionArgs = FindManyQuestionArgsFromQuestion
FindFirstQuestionArgs = FindManyQuestionArgsFromQuestion


    

class QuestionWhereInput(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntFilter']
    SurveyID: Union[_int, 'types.IntFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    survey: 'SurveyRelationFilter'
    optionalAnswers: 'OptionalAnswerListRelationFilter'
    userAnswers: 'UserAnswerListRelationFilter'
    followingQuestions: 'OptionalAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['QuestionWhereInputRecursive1', List['QuestionWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['QuestionWhereInputRecursive1']
    OR: List['QuestionWhereInputRecursive1']
    NOT: List['QuestionWhereInputRecursive1']


class QuestionWhereInputRecursive1(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntFilter']
    SurveyID: Union[_int, 'types.IntFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    survey: 'SurveyRelationFilter'
    optionalAnswers: 'OptionalAnswerListRelationFilter'
    userAnswers: 'UserAnswerListRelationFilter'
    followingQuestions: 'OptionalAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['QuestionWhereInputRecursive2', List['QuestionWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['QuestionWhereInputRecursive2']
    OR: List['QuestionWhereInputRecursive2']
    NOT: List['QuestionWhereInputRecursive2']


class QuestionWhereInputRecursive2(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntFilter']
    SurveyID: Union[_int, 'types.IntFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    survey: 'SurveyRelationFilter'
    optionalAnswers: 'OptionalAnswerListRelationFilter'
    userAnswers: 'UserAnswerListRelationFilter'
    followingQuestions: 'OptionalAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['QuestionWhereInputRecursive3', List['QuestionWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['QuestionWhereInputRecursive3']
    OR: List['QuestionWhereInputRecursive3']
    NOT: List['QuestionWhereInputRecursive3']


class QuestionWhereInputRecursive3(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntFilter']
    SurveyID: Union[_int, 'types.IntFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    survey: 'SurveyRelationFilter'
    optionalAnswers: 'OptionalAnswerListRelationFilter'
    userAnswers: 'UserAnswerListRelationFilter'
    followingQuestions: 'OptionalAnswerListRelationFilter'

    # should be noted that AND and NOT should be Union['QuestionWhereInputRecursive4', List['QuestionWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['QuestionWhereInputRecursive4']
    OR: List['QuestionWhereInputRecursive4']
    NOT: List['QuestionWhereInputRecursive4']


class QuestionWhereInputRecursive4(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntFilter']
    SurveyID: Union[_int, 'types.IntFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    survey: 'SurveyRelationFilter'
    optionalAnswers: 'OptionalAnswerListRelationFilter'
    userAnswers: 'UserAnswerListRelationFilter'
    followingQuestions: 'OptionalAnswerListRelationFilter'



# aggregate Question types


    

class QuestionScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['QuestionScalarWhereWithAggregatesInputRecursive1']
    OR: List['QuestionScalarWhereWithAggregatesInputRecursive1']
    NOT: List['QuestionScalarWhereWithAggregatesInputRecursive1']


class QuestionScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['QuestionScalarWhereWithAggregatesInputRecursive2']
    OR: List['QuestionScalarWhereWithAggregatesInputRecursive2']
    NOT: List['QuestionScalarWhereWithAggregatesInputRecursive2']


class QuestionScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['QuestionScalarWhereWithAggregatesInputRecursive3']
    OR: List['QuestionScalarWhereWithAggregatesInputRecursive3']
    NOT: List['QuestionScalarWhereWithAggregatesInputRecursive3']


class QuestionScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['QuestionScalarWhereWithAggregatesInputRecursive4']
    OR: List['QuestionScalarWhereWithAggregatesInputRecursive4']
    NOT: List['QuestionScalarWhereWithAggregatesInputRecursive4']


class QuestionScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Question arguments for searching"""
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    SurveyID: Union[_int, 'types.IntWithAggregatesFilter']
    Type: 'enums.enumQtype'
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']



class QuestionGroupByOutput(TypedDict, total=False):
    QuestionID: _int
    SurveyID: _int
    Type: 'enums.enumQtype'
    Text: _str
    Order: _int
    _sum: 'QuestionSumAggregateOutput'
    _avg: 'QuestionAvgAggregateOutput'
    _min: 'QuestionMinAggregateOutput'
    _max: 'QuestionMaxAggregateOutput'
    _count: 'QuestionCountAggregateOutput'


class QuestionAvgAggregateOutput(TypedDict, total=False):
    """Question output for aggregating averages"""
    QuestionID: float
    SurveyID: float
    Order: float


class QuestionSumAggregateOutput(TypedDict, total=False):
    """Question output for aggregating sums"""
    QuestionID: _int
    SurveyID: _int
    Order: _int


class QuestionScalarAggregateOutput(TypedDict, total=False):
    """Question output including scalar fields"""
    QuestionID: _int
    SurveyID: _int
    Type: 'enums.enumQtype'
    Text: _str
    Order: _int


QuestionMinAggregateOutput = QuestionScalarAggregateOutput
QuestionMaxAggregateOutput = QuestionScalarAggregateOutput


class QuestionMaxAggregateInput(TypedDict, total=False):
    """Question input for aggregating by max"""
    QuestionID: bool
    SurveyID: bool
    Type: bool
    Text: bool
    Order: bool


class QuestionMinAggregateInput(TypedDict, total=False):
    """Question input for aggregating by min"""
    QuestionID: bool
    SurveyID: bool
    Type: bool
    Text: bool
    Order: bool


class QuestionNumberAggregateInput(TypedDict, total=False):
    """Question input for aggregating numbers"""
    QuestionID: bool
    SurveyID: bool
    Order: bool


QuestionAvgAggregateInput = QuestionNumberAggregateInput
QuestionSumAggregateInput = QuestionNumberAggregateInput


QuestionCountAggregateInput = TypedDict(
    'QuestionCountAggregateInput',
    {
        'QuestionID': bool,
        'SurveyID': bool,
        'Type': bool,
        'Text': bool,
        'Order': bool,
        '_all': bool,
    },
    total=False,
)

QuestionCountAggregateOutput = TypedDict(
    'QuestionCountAggregateOutput',
    {
        'QuestionID': int,
        'SurveyID': int,
        'Type': int,
        'Text': int,
        'Order': int,
        '_all': int,
    },
    total=False,
)


QuestionKeys = Literal[
    'QuestionID',
    'SurveyID',
    'Type',
    'Text',
    'Order',
    'survey',
    'optionalAnswers',
    'userAnswers',
    'followingQuestions',
]
QuestionScalarFieldKeys = Literal[
    'QuestionID',
    'SurveyID',
    'Type',
    'Text',
    'Order',
]
QuestionScalarFieldKeysT = TypeVar('QuestionScalarFieldKeysT', bound=QuestionScalarFieldKeys)

QuestionRelationalFieldKeys = Literal[
        'survey',
        'optionalAnswers',
        'userAnswers',
        'followingQuestions',
    ]

# OptionalAnswer types

class OptionalAnswerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the OptionalAnswer create method"""
    AnswerID: _int
    QuestionID: _int
    followingQuestionID: Optional[_int]
    question: 'QuestionCreateNestedWithoutRelationsInput'
    followingQuestion: 'QuestionCreateNestedWithoutRelationsInput'


class OptionalAnswerCreateInput(OptionalAnswerOptionalCreateInput):
    """Required arguments to the OptionalAnswer create method"""
    Text: _str
    Order: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class OptionalAnswerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the OptionalAnswer create method, without relations"""
    AnswerID: _int
    QuestionID: _int
    followingQuestionID: Optional[_int]


class OptionalAnswerCreateWithoutRelationsInput(OptionalAnswerOptionalCreateWithoutRelationsInput):
    """Required arguments to the OptionalAnswer create method, without relations"""
    Text: _str
    Order: _int


class OptionalAnswerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'OptionalAnswerCreateWithoutRelationsInput'
    connect: 'OptionalAnswerWhereUniqueInput'


class OptionalAnswerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['OptionalAnswerCreateWithoutRelationsInput', List['OptionalAnswerCreateWithoutRelationsInput']]
    connect: Union['OptionalAnswerWhereUniqueInput', List['OptionalAnswerWhereUniqueInput']]


_OptionalAnswerWhereUnique_AnswerID_Input = TypedDict(
    '_OptionalAnswerWhereUnique_AnswerID_Input',
    {
        'AnswerID': '_int',
    },
    total=True
)

OptionalAnswerWhereUniqueInput = _OptionalAnswerWhereUnique_AnswerID_Input


class OptionalAnswerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    AnswerID: Union[AtomicIntInput, _int]
    Text: _str
    Order: Union[AtomicIntInput, _int]
    question: 'QuestionUpdateOneWithoutRelationsInput'
    followingQuestion: 'QuestionUpdateOneWithoutRelationsInput'


class OptionalAnswerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    AnswerID: Union[AtomicIntInput, _int]
    Text: _str
    Order: Union[AtomicIntInput, _int]


class OptionalAnswerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['OptionalAnswerCreateWithoutRelationsInput']
    connect: List['OptionalAnswerWhereUniqueInput']
    set: List['OptionalAnswerWhereUniqueInput']
    disconnect: List['OptionalAnswerWhereUniqueInput']
    delete: List['OptionalAnswerWhereUniqueInput']

    # TODO
    # update: List['OptionalAnswerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['OptionalAnswerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['OptionalAnswerScalarWhereInput']
    # upsert: List['OptionalAnswerUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['OptionalAnswerCreateOrConnectWithoutRelationsInput']


class OptionalAnswerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'OptionalAnswerCreateWithoutRelationsInput'
    connect: 'OptionalAnswerWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'OptionalAnswerUpdateInput'
    # upsert: 'OptionalAnswerUpsertWithoutRelationsInput'
    # connectOrCreate: 'OptionalAnswerCreateOrConnectWithoutRelationsInput'


class OptionalAnswerUpsertInput(TypedDict):
    create: 'OptionalAnswerCreateInput'
    update: 'OptionalAnswerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_OptionalAnswer_AnswerID_OrderByInput = TypedDict(
    '_OptionalAnswer_AnswerID_OrderByInput',
    {
        'AnswerID': 'SortOrder',
    },
    total=True
)

_OptionalAnswer_QuestionID_OrderByInput = TypedDict(
    '_OptionalAnswer_QuestionID_OrderByInput',
    {
        'QuestionID': 'SortOrder',
    },
    total=True
)

_OptionalAnswer_Text_OrderByInput = TypedDict(
    '_OptionalAnswer_Text_OrderByInput',
    {
        'Text': 'SortOrder',
    },
    total=True
)

_OptionalAnswer_Order_OrderByInput = TypedDict(
    '_OptionalAnswer_Order_OrderByInput',
    {
        'Order': 'SortOrder',
    },
    total=True
)

_OptionalAnswer_followingQuestionID_OrderByInput = TypedDict(
    '_OptionalAnswer_followingQuestionID_OrderByInput',
    {
        'followingQuestionID': 'SortOrder',
    },
    total=True
)

OptionalAnswerOrderByInput = Union[
    '_OptionalAnswer_AnswerID_OrderByInput',
    '_OptionalAnswer_QuestionID_OrderByInput',
    '_OptionalAnswer_Text_OrderByInput',
    '_OptionalAnswer_Order_OrderByInput',
    '_OptionalAnswer_followingQuestionID_OrderByInput',
]



# recursive OptionalAnswer types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

OptionalAnswerRelationFilter = TypedDict(
    'OptionalAnswerRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class OptionalAnswerListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class OptionalAnswerInclude(TypedDict, total=False):
    """OptionalAnswer relational arguments"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswer']
    followingQuestion: Union[bool, 'QuestionArgsFromOptionalAnswer']


    

class SurveyIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromOptionalAnswerRecursive1']


class SurveyIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromOptionalAnswerRecursive2']


class SurveyIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromOptionalAnswerRecursive3']


class SurveyIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromOptionalAnswerRecursive4']


class SurveyIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class SurveyArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManySurveyArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    survey: Union[bool, 'SurveyArgsFromOptionalAnswerRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromOptionalAnswerRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive1']


class QuestionIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    survey: Union[bool, 'SurveyArgsFromOptionalAnswerRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromOptionalAnswerRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive2']


class QuestionIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    survey: Union[bool, 'SurveyArgsFromOptionalAnswerRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromOptionalAnswerRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive3']


class QuestionIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    survey: Union[bool, 'SurveyArgsFromOptionalAnswerRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromOptionalAnswerRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromOptionalAnswerRecursive4']


class QuestionIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class QuestionArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManyQuestionArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive1']


class OptionalAnswerIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive2']


class OptionalAnswerIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive3']


class OptionalAnswerIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive4']


class OptionalAnswerIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class OptionalAnswerArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManyOptionalAnswerArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive1']


class UserAnswerIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive2']


class UserAnswerIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive3']


class UserAnswerIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    question: Union[bool, 'QuestionArgsFromOptionalAnswerRecursive4']


class UserAnswerIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class UserAnswerArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManyUserAnswerArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    settlement: Union[bool, 'SettlementArgsFromOptionalAnswerRecursive1']


class UserAnswerNewIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    settlement: Union[bool, 'SettlementArgsFromOptionalAnswerRecursive2']


class UserAnswerNewIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    settlement: Union[bool, 'SettlementArgsFromOptionalAnswerRecursive3']


class UserAnswerNewIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    settlement: Union[bool, 'SettlementArgsFromOptionalAnswerRecursive4']


class UserAnswerNewIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class UserAnswerNewArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManyUserAnswerNewArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromOptionalAnswer(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromOptionalAnswerRecursive1']


class SettlementIncludeFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromOptionalAnswerRecursive2']


class SettlementIncludeFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromOptionalAnswerRecursive3']


class SettlementIncludeFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromOptionalAnswerRecursive4']


class SettlementIncludeFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for OptionalAnswer"""

    

class SettlementArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    
    

class FindManySettlementArgsFromOptionalAnswer(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromOptionalAnswerRecursive1(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromOptionalAnswerRecursive2(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromOptionalAnswerRecursive3(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromOptionalAnswerRecursive4(TypedDict, total=False):
    """Arguments for OptionalAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManyOptionalAnswerArgs = FindManyOptionalAnswerArgsFromOptionalAnswer
FindFirstOptionalAnswerArgs = FindManyOptionalAnswerArgsFromOptionalAnswer


    

class OptionalAnswerWhereInput(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    followingQuestionID: Union[None, _int, 'types.IntFilter']
    question: 'QuestionRelationFilter'
    followingQuestion: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['OptionalAnswerWhereInputRecursive1', List['OptionalAnswerWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['OptionalAnswerWhereInputRecursive1']
    OR: List['OptionalAnswerWhereInputRecursive1']
    NOT: List['OptionalAnswerWhereInputRecursive1']


class OptionalAnswerWhereInputRecursive1(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    followingQuestionID: Union[None, _int, 'types.IntFilter']
    question: 'QuestionRelationFilter'
    followingQuestion: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['OptionalAnswerWhereInputRecursive2', List['OptionalAnswerWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['OptionalAnswerWhereInputRecursive2']
    OR: List['OptionalAnswerWhereInputRecursive2']
    NOT: List['OptionalAnswerWhereInputRecursive2']


class OptionalAnswerWhereInputRecursive2(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    followingQuestionID: Union[None, _int, 'types.IntFilter']
    question: 'QuestionRelationFilter'
    followingQuestion: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['OptionalAnswerWhereInputRecursive3', List['OptionalAnswerWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['OptionalAnswerWhereInputRecursive3']
    OR: List['OptionalAnswerWhereInputRecursive3']
    NOT: List['OptionalAnswerWhereInputRecursive3']


class OptionalAnswerWhereInputRecursive3(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    followingQuestionID: Union[None, _int, 'types.IntFilter']
    question: 'QuestionRelationFilter'
    followingQuestion: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['OptionalAnswerWhereInputRecursive4', List['OptionalAnswerWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['OptionalAnswerWhereInputRecursive4']
    OR: List['OptionalAnswerWhereInputRecursive4']
    NOT: List['OptionalAnswerWhereInputRecursive4']


class OptionalAnswerWhereInputRecursive4(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    Text: Union[_str, 'types.StringFilter']
    Order: Union[_int, 'types.IntFilter']
    followingQuestionID: Union[None, _int, 'types.IntFilter']
    question: 'QuestionRelationFilter'
    followingQuestion: 'QuestionRelationFilter'



# aggregate OptionalAnswer types


    

class OptionalAnswerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']
    followingQuestionID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive1']
    OR: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive1']
    NOT: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive1']


class OptionalAnswerScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']
    followingQuestionID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive2']
    OR: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive2']
    NOT: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive2']


class OptionalAnswerScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']
    followingQuestionID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive3']
    OR: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive3']
    NOT: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive3']


class OptionalAnswerScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']
    followingQuestionID: Union[_int, 'types.IntWithAggregatesFilter']

    AND: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive4']
    OR: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive4']
    NOT: List['OptionalAnswerScalarWhereWithAggregatesInputRecursive4']


class OptionalAnswerScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """OptionalAnswer arguments for searching"""
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Order: Union[_int, 'types.IntWithAggregatesFilter']
    followingQuestionID: Union[_int, 'types.IntWithAggregatesFilter']



class OptionalAnswerGroupByOutput(TypedDict, total=False):
    AnswerID: _int
    QuestionID: _int
    Text: _str
    Order: _int
    followingQuestionID: _int
    _sum: 'OptionalAnswerSumAggregateOutput'
    _avg: 'OptionalAnswerAvgAggregateOutput'
    _min: 'OptionalAnswerMinAggregateOutput'
    _max: 'OptionalAnswerMaxAggregateOutput'
    _count: 'OptionalAnswerCountAggregateOutput'


class OptionalAnswerAvgAggregateOutput(TypedDict, total=False):
    """OptionalAnswer output for aggregating averages"""
    AnswerID: float
    QuestionID: float
    Order: float
    followingQuestionID: float


class OptionalAnswerSumAggregateOutput(TypedDict, total=False):
    """OptionalAnswer output for aggregating sums"""
    AnswerID: _int
    QuestionID: _int
    Order: _int
    followingQuestionID: _int


class OptionalAnswerScalarAggregateOutput(TypedDict, total=False):
    """OptionalAnswer output including scalar fields"""
    AnswerID: _int
    QuestionID: _int
    Text: _str
    Order: _int
    followingQuestionID: _int


OptionalAnswerMinAggregateOutput = OptionalAnswerScalarAggregateOutput
OptionalAnswerMaxAggregateOutput = OptionalAnswerScalarAggregateOutput


class OptionalAnswerMaxAggregateInput(TypedDict, total=False):
    """OptionalAnswer input for aggregating by max"""
    AnswerID: bool
    QuestionID: bool
    Text: bool
    Order: bool
    followingQuestionID: bool


class OptionalAnswerMinAggregateInput(TypedDict, total=False):
    """OptionalAnswer input for aggregating by min"""
    AnswerID: bool
    QuestionID: bool
    Text: bool
    Order: bool
    followingQuestionID: bool


class OptionalAnswerNumberAggregateInput(TypedDict, total=False):
    """OptionalAnswer input for aggregating numbers"""
    AnswerID: bool
    QuestionID: bool
    Order: bool
    followingQuestionID: bool


OptionalAnswerAvgAggregateInput = OptionalAnswerNumberAggregateInput
OptionalAnswerSumAggregateInput = OptionalAnswerNumberAggregateInput


OptionalAnswerCountAggregateInput = TypedDict(
    'OptionalAnswerCountAggregateInput',
    {
        'AnswerID': bool,
        'QuestionID': bool,
        'Text': bool,
        'Order': bool,
        'followingQuestionID': bool,
        '_all': bool,
    },
    total=False,
)

OptionalAnswerCountAggregateOutput = TypedDict(
    'OptionalAnswerCountAggregateOutput',
    {
        'AnswerID': int,
        'QuestionID': int,
        'Text': int,
        'Order': int,
        'followingQuestionID': int,
        '_all': int,
    },
    total=False,
)


OptionalAnswerKeys = Literal[
    'AnswerID',
    'QuestionID',
    'Text',
    'Order',
    'followingQuestionID',
    'question',
    'followingQuestion',
]
OptionalAnswerScalarFieldKeys = Literal[
    'AnswerID',
    'QuestionID',
    'Text',
    'Order',
    'followingQuestionID',
]
OptionalAnswerScalarFieldKeysT = TypeVar('OptionalAnswerScalarFieldKeysT', bound=OptionalAnswerScalarFieldKeys)

OptionalAnswerRelationalFieldKeys = Literal[
        'question',
        'followingQuestion',
    ]

# UserAnswer types

class UserAnswerOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserAnswer create method"""
    QuestionID: _int
    Text: Optional[_str]
    Location: Optional[_str]
    question: 'QuestionCreateNestedWithoutRelationsInput'


class UserAnswerCreateInput(UserAnswerOptionalCreateInput):
    """Required arguments to the UserAnswer create method"""
    PersonID: _int
    AnswerID: _int
    Timestamp: datetime.datetime


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserAnswerOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserAnswer create method, without relations"""
    QuestionID: _int
    Text: Optional[_str]
    Location: Optional[_str]


class UserAnswerCreateWithoutRelationsInput(UserAnswerOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserAnswer create method, without relations"""
    PersonID: _int
    AnswerID: _int
    Timestamp: datetime.datetime


class UserAnswerCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerCreateWithoutRelationsInput'
    connect: 'UserAnswerWhereUniqueInput'


class UserAnswerCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserAnswerCreateWithoutRelationsInput', List['UserAnswerCreateWithoutRelationsInput']]
    connect: Union['UserAnswerWhereUniqueInput', List['UserAnswerWhereUniqueInput']]


_UserAnswerCompoundPrimaryKeyInner = TypedDict(
    '_UserAnswerCompoundPrimaryKeyInner',
    {
        'PersonID': '_int',
        'QuestionID': '_int',
    },
    total=True
)

_UserAnswerCompoundPrimaryKey = TypedDict(
    '_UserAnswerCompoundPrimaryKey',
    {
        'PersonID_QuestionID': '_UserAnswerCompoundPrimaryKeyInner',
    },
    total=True
)

UserAnswerWhereUniqueInput = _UserAnswerCompoundPrimaryKey


class UserAnswerUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    PersonID: Union[AtomicIntInput, _int]
    AnswerID: Union[AtomicIntInput, _int]
    Text: Optional[_str]
    Location: Optional[_str]
    Timestamp: datetime.datetime
    question: 'QuestionUpdateOneWithoutRelationsInput'


class UserAnswerUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    PersonID: Union[AtomicIntInput, _int]
    AnswerID: Union[AtomicIntInput, _int]
    Text: Optional[_str]
    Location: Optional[_str]
    Timestamp: datetime.datetime


class UserAnswerUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserAnswerCreateWithoutRelationsInput']
    connect: List['UserAnswerWhereUniqueInput']
    set: List['UserAnswerWhereUniqueInput']
    disconnect: List['UserAnswerWhereUniqueInput']
    delete: List['UserAnswerWhereUniqueInput']

    # TODO
    # update: List['UserAnswerUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserAnswerUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserAnswerScalarWhereInput']
    # upsert: List['UserAnswerUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserAnswerCreateOrConnectWithoutRelationsInput']


class UserAnswerUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerCreateWithoutRelationsInput'
    connect: 'UserAnswerWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserAnswerUpdateInput'
    # upsert: 'UserAnswerUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserAnswerCreateOrConnectWithoutRelationsInput'


class UserAnswerUpsertInput(TypedDict):
    create: 'UserAnswerCreateInput'
    update: 'UserAnswerUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserAnswer_PersonID_OrderByInput = TypedDict(
    '_UserAnswer_PersonID_OrderByInput',
    {
        'PersonID': 'SortOrder',
    },
    total=True
)

_UserAnswer_QuestionID_OrderByInput = TypedDict(
    '_UserAnswer_QuestionID_OrderByInput',
    {
        'QuestionID': 'SortOrder',
    },
    total=True
)

_UserAnswer_AnswerID_OrderByInput = TypedDict(
    '_UserAnswer_AnswerID_OrderByInput',
    {
        'AnswerID': 'SortOrder',
    },
    total=True
)

_UserAnswer_Text_OrderByInput = TypedDict(
    '_UserAnswer_Text_OrderByInput',
    {
        'Text': 'SortOrder',
    },
    total=True
)

_UserAnswer_Location_OrderByInput = TypedDict(
    '_UserAnswer_Location_OrderByInput',
    {
        'Location': 'SortOrder',
    },
    total=True
)

_UserAnswer_Timestamp_OrderByInput = TypedDict(
    '_UserAnswer_Timestamp_OrderByInput',
    {
        'Timestamp': 'SortOrder',
    },
    total=True
)

UserAnswerOrderByInput = Union[
    '_UserAnswer_PersonID_OrderByInput',
    '_UserAnswer_QuestionID_OrderByInput',
    '_UserAnswer_AnswerID_OrderByInput',
    '_UserAnswer_Text_OrderByInput',
    '_UserAnswer_Location_OrderByInput',
    '_UserAnswer_Timestamp_OrderByInput',
]



# recursive UserAnswer types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserAnswerRelationFilter = TypedDict(
    'UserAnswerRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserAnswerListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserAnswerInclude(TypedDict, total=False):
    """UserAnswer relational arguments"""
    question: Union[bool, 'QuestionArgsFromUserAnswer']


    

class SurveyIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerRecursive1']


class SurveyIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerRecursive2']


class SurveyIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerRecursive3']


class SurveyIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerRecursive4']


class SurveyIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class SurveyArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManySurveyArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive1']


class QuestionIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive2']


class QuestionIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive3']


class QuestionIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerRecursive4']


class QuestionIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class QuestionArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManyQuestionArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerRecursive1']


class OptionalAnswerIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerRecursive2']


class OptionalAnswerIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerRecursive3']


class OptionalAnswerIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerRecursive4']


class OptionalAnswerIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class OptionalAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManyOptionalAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive1']


class UserAnswerIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive2']


class UserAnswerIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive3']


class UserAnswerIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    question: Union[bool, 'QuestionArgsFromUserAnswerRecursive4']


class UserAnswerIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class UserAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManyUserAnswerArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive1']


class UserAnswerNewIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive2']


class UserAnswerNewIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive3']


class UserAnswerNewIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerRecursive4']


class UserAnswerNewIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class UserAnswerNewArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManyUserAnswerNewArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromUserAnswer(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerRecursive1']


class SettlementIncludeFromUserAnswerRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerRecursive2']


class SettlementIncludeFromUserAnswerRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerRecursive3']


class SettlementIncludeFromUserAnswerRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswer"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerRecursive4']


class SettlementIncludeFromUserAnswerRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswer"""

    

class SettlementArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    
    

class FindManySettlementArgsFromUserAnswer(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromUserAnswerRecursive1(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromUserAnswerRecursive2(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromUserAnswerRecursive3(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromUserAnswerRecursive4(TypedDict, total=False):
    """Arguments for UserAnswer"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManyUserAnswerArgs = FindManyUserAnswerArgsFromUserAnswer
FindFirstUserAnswerArgs = FindManyUserAnswerArgsFromUserAnswer


    

class UserAnswerWhereInput(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    AnswerID: Union[_int, 'types.IntFilter']
    Text: Union[None, _str, 'types.StringFilter']
    Location: Union[None, _str, 'types.StringFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    question: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive1', List['UserAnswerWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive1']
    OR: List['UserAnswerWhereInputRecursive1']
    NOT: List['UserAnswerWhereInputRecursive1']


class UserAnswerWhereInputRecursive1(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    AnswerID: Union[_int, 'types.IntFilter']
    Text: Union[None, _str, 'types.StringFilter']
    Location: Union[None, _str, 'types.StringFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    question: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive2', List['UserAnswerWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive2']
    OR: List['UserAnswerWhereInputRecursive2']
    NOT: List['UserAnswerWhereInputRecursive2']


class UserAnswerWhereInputRecursive2(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    AnswerID: Union[_int, 'types.IntFilter']
    Text: Union[None, _str, 'types.StringFilter']
    Location: Union[None, _str, 'types.StringFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    question: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive3', List['UserAnswerWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive3']
    OR: List['UserAnswerWhereInputRecursive3']
    NOT: List['UserAnswerWhereInputRecursive3']


class UserAnswerWhereInputRecursive3(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    AnswerID: Union[_int, 'types.IntFilter']
    Text: Union[None, _str, 'types.StringFilter']
    Location: Union[None, _str, 'types.StringFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    question: 'QuestionRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerWhereInputRecursive4', List['UserAnswerWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerWhereInputRecursive4']
    OR: List['UserAnswerWhereInputRecursive4']
    NOT: List['UserAnswerWhereInputRecursive4']


class UserAnswerWhereInputRecursive4(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntFilter']
    QuestionID: Union[_int, 'types.IntFilter']
    AnswerID: Union[_int, 'types.IntFilter']
    Text: Union[None, _str, 'types.StringFilter']
    Location: Union[None, _str, 'types.StringFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeFilter']
    question: 'QuestionRelationFilter'



# aggregate UserAnswer types


    

class UserAnswerScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Location: Union[_str, 'types.StringWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive1']


class UserAnswerScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Location: Union[_str, 'types.StringWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive2']


class UserAnswerScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Location: Union[_str, 'types.StringWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive3']


class UserAnswerScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Location: Union[_str, 'types.StringWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']

    AND: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserAnswerScalarWhereWithAggregatesInputRecursive4']


class UserAnswerScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """UserAnswer arguments for searching"""
    PersonID: Union[_int, 'types.IntWithAggregatesFilter']
    QuestionID: Union[_int, 'types.IntWithAggregatesFilter']
    AnswerID: Union[_int, 'types.IntWithAggregatesFilter']
    Text: Union[_str, 'types.StringWithAggregatesFilter']
    Location: Union[_str, 'types.StringWithAggregatesFilter']
    Timestamp: Union[datetime.datetime, 'types.DateTimeWithAggregatesFilter']



class UserAnswerGroupByOutput(TypedDict, total=False):
    PersonID: _int
    QuestionID: _int
    AnswerID: _int
    Text: _str
    Location: _str
    Timestamp: datetime.datetime
    _sum: 'UserAnswerSumAggregateOutput'
    _avg: 'UserAnswerAvgAggregateOutput'
    _min: 'UserAnswerMinAggregateOutput'
    _max: 'UserAnswerMaxAggregateOutput'
    _count: 'UserAnswerCountAggregateOutput'


class UserAnswerAvgAggregateOutput(TypedDict, total=False):
    """UserAnswer output for aggregating averages"""
    PersonID: float
    QuestionID: float
    AnswerID: float


class UserAnswerSumAggregateOutput(TypedDict, total=False):
    """UserAnswer output for aggregating sums"""
    PersonID: _int
    QuestionID: _int
    AnswerID: _int


class UserAnswerScalarAggregateOutput(TypedDict, total=False):
    """UserAnswer output including scalar fields"""
    PersonID: _int
    QuestionID: _int
    AnswerID: _int
    Text: _str
    Location: _str
    Timestamp: datetime.datetime


UserAnswerMinAggregateOutput = UserAnswerScalarAggregateOutput
UserAnswerMaxAggregateOutput = UserAnswerScalarAggregateOutput


class UserAnswerMaxAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating by max"""
    PersonID: bool
    QuestionID: bool
    AnswerID: bool
    Text: bool
    Location: bool
    Timestamp: bool


class UserAnswerMinAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating by min"""
    PersonID: bool
    QuestionID: bool
    AnswerID: bool
    Text: bool
    Location: bool
    Timestamp: bool


class UserAnswerNumberAggregateInput(TypedDict, total=False):
    """UserAnswer input for aggregating numbers"""
    PersonID: bool
    QuestionID: bool
    AnswerID: bool


UserAnswerAvgAggregateInput = UserAnswerNumberAggregateInput
UserAnswerSumAggregateInput = UserAnswerNumberAggregateInput


UserAnswerCountAggregateInput = TypedDict(
    'UserAnswerCountAggregateInput',
    {
        'PersonID': bool,
        'QuestionID': bool,
        'AnswerID': bool,
        'Text': bool,
        'Location': bool,
        'Timestamp': bool,
        '_all': bool,
    },
    total=False,
)

UserAnswerCountAggregateOutput = TypedDict(
    'UserAnswerCountAggregateOutput',
    {
        'PersonID': int,
        'QuestionID': int,
        'AnswerID': int,
        'Text': int,
        'Location': int,
        'Timestamp': int,
        '_all': int,
    },
    total=False,
)


UserAnswerKeys = Literal[
    'PersonID',
    'QuestionID',
    'AnswerID',
    'Text',
    'Location',
    'Timestamp',
    'question',
]
UserAnswerScalarFieldKeys = Literal[
    'PersonID',
    'QuestionID',
    'AnswerID',
    'Text',
    'Location',
    'Timestamp',
]
UserAnswerScalarFieldKeysT = TypeVar('UserAnswerScalarFieldKeysT', bound=UserAnswerScalarFieldKeys)

UserAnswerRelationalFieldKeys = Literal[
        'question',
    ]

# UserAnswerNew types

class UserAnswerNewOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the UserAnswerNew create method"""
    id: _int
    settlementCode: _int
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]
    settlement: 'SettlementCreateNestedWithoutRelationsInput'


class UserAnswerNewCreateInput(UserAnswerNewOptionalCreateInput):
    """Required arguments to the UserAnswerNew create method"""
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class UserAnswerNewOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the UserAnswerNew create method, without relations"""
    id: _int
    settlementCode: _int
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]


class UserAnswerNewCreateWithoutRelationsInput(UserAnswerNewOptionalCreateWithoutRelationsInput):
    """Required arguments to the UserAnswerNew create method, without relations"""
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int


class UserAnswerNewCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerNewCreateWithoutRelationsInput'
    connect: 'UserAnswerNewWhereUniqueInput'


class UserAnswerNewCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['UserAnswerNewCreateWithoutRelationsInput', List['UserAnswerNewCreateWithoutRelationsInput']]
    connect: Union['UserAnswerNewWhereUniqueInput', List['UserAnswerNewWhereUniqueInput']]


_UserAnswerNewWhereUnique_id_Input = TypedDict(
    '_UserAnswerNewWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_UserAnswerNewWhereUnique_idNumber_Input = TypedDict(
    '_UserAnswerNewWhereUnique_idNumber_Input',
    {
        'idNumber': '_str',
    },
    total=True
)

UserAnswerNewWhereUniqueInput = Union[
    '_UserAnswerNewWhereUnique_id_Input',
    '_UserAnswerNewWhereUnique_idNumber_Input',
]


class UserAnswerNewUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: Union[AtomicIntInput, _int]
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]
    settlement: 'SettlementUpdateOneWithoutRelationsInput'


class UserAnswerNewUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    idNumber: _str
    fullName: _str
    accessibility: _bool
    pets: _bool
    numberOfPeople: Union[AtomicIntInput, _int]
    hotelOption1: Optional[_str]
    hotelOption2: Optional[_str]
    hotelOption3: Optional[_str]
    selectedHotel: Optional[_str]


class UserAnswerNewUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['UserAnswerNewCreateWithoutRelationsInput']
    connect: List['UserAnswerNewWhereUniqueInput']
    set: List['UserAnswerNewWhereUniqueInput']
    disconnect: List['UserAnswerNewWhereUniqueInput']
    delete: List['UserAnswerNewWhereUniqueInput']

    # TODO
    # update: List['UserAnswerNewUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['UserAnswerNewUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['UserAnswerNewScalarWhereInput']
    # upsert: List['UserAnswerNewUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['UserAnswerNewCreateOrConnectWithoutRelationsInput']


class UserAnswerNewUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'UserAnswerNewCreateWithoutRelationsInput'
    connect: 'UserAnswerNewWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'UserAnswerNewUpdateInput'
    # upsert: 'UserAnswerNewUpsertWithoutRelationsInput'
    # connectOrCreate: 'UserAnswerNewCreateOrConnectWithoutRelationsInput'


class UserAnswerNewUpsertInput(TypedDict):
    create: 'UserAnswerNewCreateInput'
    update: 'UserAnswerNewUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_UserAnswerNew_id_OrderByInput = TypedDict(
    '_UserAnswerNew_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_idNumber_OrderByInput = TypedDict(
    '_UserAnswerNew_idNumber_OrderByInput',
    {
        'idNumber': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_fullName_OrderByInput = TypedDict(
    '_UserAnswerNew_fullName_OrderByInput',
    {
        'fullName': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_settlementCode_OrderByInput = TypedDict(
    '_UserAnswerNew_settlementCode_OrderByInput',
    {
        'settlementCode': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_accessibility_OrderByInput = TypedDict(
    '_UserAnswerNew_accessibility_OrderByInput',
    {
        'accessibility': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_pets_OrderByInput = TypedDict(
    '_UserAnswerNew_pets_OrderByInput',
    {
        'pets': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_numberOfPeople_OrderByInput = TypedDict(
    '_UserAnswerNew_numberOfPeople_OrderByInput',
    {
        'numberOfPeople': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_hotelOption1_OrderByInput = TypedDict(
    '_UserAnswerNew_hotelOption1_OrderByInput',
    {
        'hotelOption1': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_hotelOption2_OrderByInput = TypedDict(
    '_UserAnswerNew_hotelOption2_OrderByInput',
    {
        'hotelOption2': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_hotelOption3_OrderByInput = TypedDict(
    '_UserAnswerNew_hotelOption3_OrderByInput',
    {
        'hotelOption3': 'SortOrder',
    },
    total=True
)

_UserAnswerNew_selectedHotel_OrderByInput = TypedDict(
    '_UserAnswerNew_selectedHotel_OrderByInput',
    {
        'selectedHotel': 'SortOrder',
    },
    total=True
)

UserAnswerNewOrderByInput = Union[
    '_UserAnswerNew_id_OrderByInput',
    '_UserAnswerNew_idNumber_OrderByInput',
    '_UserAnswerNew_fullName_OrderByInput',
    '_UserAnswerNew_settlementCode_OrderByInput',
    '_UserAnswerNew_accessibility_OrderByInput',
    '_UserAnswerNew_pets_OrderByInput',
    '_UserAnswerNew_numberOfPeople_OrderByInput',
    '_UserAnswerNew_hotelOption1_OrderByInput',
    '_UserAnswerNew_hotelOption2_OrderByInput',
    '_UserAnswerNew_hotelOption3_OrderByInput',
    '_UserAnswerNew_selectedHotel_OrderByInput',
]



# recursive UserAnswerNew types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

UserAnswerNewRelationFilter = TypedDict(
    'UserAnswerNewRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class UserAnswerNewListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class UserAnswerNewInclude(TypedDict, total=False):
    """UserAnswerNew relational arguments"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerNew']


    

class SurveyIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerNewRecursive1']


class SurveyIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerNewRecursive2']


class SurveyIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerNewRecursive3']


class SurveyIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    questions: Union[bool, 'FindManyQuestionArgsFromUserAnswerNewRecursive4']


class SurveyIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class SurveyArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManySurveyArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerNewRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerNewRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive1']


class QuestionIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerNewRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerNewRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive2']


class QuestionIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerNewRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerNewRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive3']


class QuestionIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    survey: Union[bool, 'SurveyArgsFromUserAnswerNewRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromUserAnswerNewRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromUserAnswerNewRecursive4']


class QuestionIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class QuestionArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManyQuestionArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive1']


class OptionalAnswerIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive2']


class OptionalAnswerIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive3']


class OptionalAnswerIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive4']


class OptionalAnswerIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class OptionalAnswerArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManyOptionalAnswerArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive1']


class UserAnswerIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive2']


class UserAnswerIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive3']


class UserAnswerIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    question: Union[bool, 'QuestionArgsFromUserAnswerNewRecursive4']


class UserAnswerIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class UserAnswerArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManyUserAnswerArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerNewRecursive1']


class UserAnswerNewIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerNewRecursive2']


class UserAnswerNewIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerNewRecursive3']


class UserAnswerNewIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    settlement: Union[bool, 'SettlementArgsFromUserAnswerNewRecursive4']


class UserAnswerNewIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class UserAnswerNewArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManyUserAnswerNewArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromUserAnswerNew(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerNewRecursive1']


class SettlementIncludeFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerNewRecursive2']


class SettlementIncludeFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerNewRecursive3']


class SettlementIncludeFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromUserAnswerNewRecursive4']


class SettlementIncludeFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Relational arguments for UserAnswerNew"""

    

class SettlementArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    
    

class FindManySettlementArgsFromUserAnswerNew(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromUserAnswerNewRecursive1(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromUserAnswerNewRecursive2(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromUserAnswerNewRecursive3(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromUserAnswerNewRecursive4(TypedDict, total=False):
    """Arguments for UserAnswerNew"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManyUserAnswerNewArgs = FindManyUserAnswerNewArgsFromUserAnswerNew
FindFirstUserAnswerNewArgs = FindManyUserAnswerNewArgsFromUserAnswerNew


    

class UserAnswerNewWhereInput(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerNewWhereInputRecursive1', List['UserAnswerNewWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerNewWhereInputRecursive1']
    OR: List['UserAnswerNewWhereInputRecursive1']
    NOT: List['UserAnswerNewWhereInputRecursive1']


class UserAnswerNewWhereInputRecursive1(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerNewWhereInputRecursive2', List['UserAnswerNewWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerNewWhereInputRecursive2']
    OR: List['UserAnswerNewWhereInputRecursive2']
    NOT: List['UserAnswerNewWhereInputRecursive2']


class UserAnswerNewWhereInputRecursive2(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerNewWhereInputRecursive3', List['UserAnswerNewWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerNewWhereInputRecursive3']
    OR: List['UserAnswerNewWhereInputRecursive3']
    NOT: List['UserAnswerNewWhereInputRecursive3']


class UserAnswerNewWhereInputRecursive3(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'

    # should be noted that AND and NOT should be Union['UserAnswerNewWhereInputRecursive4', List['UserAnswerNewWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['UserAnswerNewWhereInputRecursive4']
    OR: List['UserAnswerNewWhereInputRecursive4']
    NOT: List['UserAnswerNewWhereInputRecursive4']


class UserAnswerNewWhereInputRecursive4(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    idNumber: Union[_str, 'types.StringFilter']
    fullName: Union[_str, 'types.StringFilter']
    settlementCode: Union[_int, 'types.IntFilter']
    accessibility: Union[_bool, 'types.BooleanFilter']
    pets: Union[_bool, 'types.BooleanFilter']
    numberOfPeople: Union[_int, 'types.IntFilter']
    hotelOption1: Union[None, _str, 'types.StringFilter']
    hotelOption2: Union[None, _str, 'types.StringFilter']
    hotelOption3: Union[None, _str, 'types.StringFilter']
    selectedHotel: Union[None, _str, 'types.StringFilter']
    settlement: 'SettlementRelationFilter'



# aggregate UserAnswerNew types


    

class UserAnswerNewScalarWhereWithAggregatesInput(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive1']
    OR: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive1']
    NOT: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive1']


class UserAnswerNewScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive2']
    OR: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive2']
    NOT: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive2']


class UserAnswerNewScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive3']
    OR: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive3']
    NOT: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive3']


class UserAnswerNewScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive4']
    OR: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive4']
    NOT: List['UserAnswerNewScalarWhereWithAggregatesInputRecursive4']


class UserAnswerNewScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """UserAnswerNew arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    idNumber: Union[_str, 'types.StringWithAggregatesFilter']
    fullName: Union[_str, 'types.StringWithAggregatesFilter']
    settlementCode: Union[_int, 'types.IntWithAggregatesFilter']
    accessibility: Union[_bool, 'types.BooleanWithAggregatesFilter']
    pets: Union[_bool, 'types.BooleanWithAggregatesFilter']
    numberOfPeople: Union[_int, 'types.IntWithAggregatesFilter']
    hotelOption1: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption2: Union[_str, 'types.StringWithAggregatesFilter']
    hotelOption3: Union[_str, 'types.StringWithAggregatesFilter']
    selectedHotel: Union[_str, 'types.StringWithAggregatesFilter']



class UserAnswerNewGroupByOutput(TypedDict, total=False):
    id: _int
    idNumber: _str
    fullName: _str
    settlementCode: _int
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int
    hotelOption1: _str
    hotelOption2: _str
    hotelOption3: _str
    selectedHotel: _str
    _sum: 'UserAnswerNewSumAggregateOutput'
    _avg: 'UserAnswerNewAvgAggregateOutput'
    _min: 'UserAnswerNewMinAggregateOutput'
    _max: 'UserAnswerNewMaxAggregateOutput'
    _count: 'UserAnswerNewCountAggregateOutput'


class UserAnswerNewAvgAggregateOutput(TypedDict, total=False):
    """UserAnswerNew output for aggregating averages"""
    id: float
    settlementCode: float
    numberOfPeople: float


class UserAnswerNewSumAggregateOutput(TypedDict, total=False):
    """UserAnswerNew output for aggregating sums"""
    id: _int
    settlementCode: _int
    numberOfPeople: _int


class UserAnswerNewScalarAggregateOutput(TypedDict, total=False):
    """UserAnswerNew output including scalar fields"""
    id: _int
    idNumber: _str
    fullName: _str
    settlementCode: _int
    accessibility: _bool
    pets: _bool
    numberOfPeople: _int
    hotelOption1: _str
    hotelOption2: _str
    hotelOption3: _str
    selectedHotel: _str


UserAnswerNewMinAggregateOutput = UserAnswerNewScalarAggregateOutput
UserAnswerNewMaxAggregateOutput = UserAnswerNewScalarAggregateOutput


class UserAnswerNewMaxAggregateInput(TypedDict, total=False):
    """UserAnswerNew input for aggregating by max"""
    id: bool
    idNumber: bool
    fullName: bool
    settlementCode: bool
    accessibility: bool
    pets: bool
    numberOfPeople: bool
    hotelOption1: bool
    hotelOption2: bool
    hotelOption3: bool
    selectedHotel: bool


class UserAnswerNewMinAggregateInput(TypedDict, total=False):
    """UserAnswerNew input for aggregating by min"""
    id: bool
    idNumber: bool
    fullName: bool
    settlementCode: bool
    accessibility: bool
    pets: bool
    numberOfPeople: bool
    hotelOption1: bool
    hotelOption2: bool
    hotelOption3: bool
    selectedHotel: bool


class UserAnswerNewNumberAggregateInput(TypedDict, total=False):
    """UserAnswerNew input for aggregating numbers"""
    id: bool
    settlementCode: bool
    numberOfPeople: bool


UserAnswerNewAvgAggregateInput = UserAnswerNewNumberAggregateInput
UserAnswerNewSumAggregateInput = UserAnswerNewNumberAggregateInput


UserAnswerNewCountAggregateInput = TypedDict(
    'UserAnswerNewCountAggregateInput',
    {
        'id': bool,
        'idNumber': bool,
        'fullName': bool,
        'settlementCode': bool,
        'accessibility': bool,
        'pets': bool,
        'numberOfPeople': bool,
        'hotelOption1': bool,
        'hotelOption2': bool,
        'hotelOption3': bool,
        'selectedHotel': bool,
        '_all': bool,
    },
    total=False,
)

UserAnswerNewCountAggregateOutput = TypedDict(
    'UserAnswerNewCountAggregateOutput',
    {
        'id': int,
        'idNumber': int,
        'fullName': int,
        'settlementCode': int,
        'accessibility': int,
        'pets': int,
        'numberOfPeople': int,
        'hotelOption1': int,
        'hotelOption2': int,
        'hotelOption3': int,
        'selectedHotel': int,
        '_all': int,
    },
    total=False,
)


UserAnswerNewKeys = Literal[
    'id',
    'idNumber',
    'fullName',
    'settlementCode',
    'accessibility',
    'pets',
    'numberOfPeople',
    'hotelOption1',
    'hotelOption2',
    'hotelOption3',
    'selectedHotel',
    'settlement',
]
UserAnswerNewScalarFieldKeys = Literal[
    'id',
    'idNumber',
    'fullName',
    'settlementCode',
    'accessibility',
    'pets',
    'numberOfPeople',
    'hotelOption1',
    'hotelOption2',
    'hotelOption3',
    'selectedHotel',
]
UserAnswerNewScalarFieldKeysT = TypeVar('UserAnswerNewScalarFieldKeysT', bound=UserAnswerNewScalarFieldKeys)

UserAnswerNewRelationalFieldKeys = Literal[
        'settlement',
    ]

# Settlement types

class SettlementOptionalCreateInput(TypedDict, total=False):
    """Optional arguments to the Settlement create method"""
    id: _int
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]
    userAnswers: 'UserAnswerNewCreateManyNestedWithoutRelationsInput'


class SettlementCreateInput(SettlementOptionalCreateInput):
    """Required arguments to the Settlement create method"""
    code: _int
    name: _str


# TODO: remove this in favour of without explicit relations
# e.g. PostCreateWithoutAuthorInput

class SettlementOptionalCreateWithoutRelationsInput(TypedDict, total=False):
    """Optional arguments to the Settlement create method, without relations"""
    id: _int
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]


class SettlementCreateWithoutRelationsInput(SettlementOptionalCreateWithoutRelationsInput):
    """Required arguments to the Settlement create method, without relations"""
    code: _int
    name: _str


class SettlementCreateNestedWithoutRelationsInput(TypedDict, total=False):
    create: 'SettlementCreateWithoutRelationsInput'
    connect: 'SettlementWhereUniqueInput'


class SettlementCreateManyNestedWithoutRelationsInput(TypedDict, total=False):
    create: Union['SettlementCreateWithoutRelationsInput', List['SettlementCreateWithoutRelationsInput']]
    connect: Union['SettlementWhereUniqueInput', List['SettlementWhereUniqueInput']]


_SettlementWhereUnique_id_Input = TypedDict(
    '_SettlementWhereUnique_id_Input',
    {
        'id': '_int',
    },
    total=True
)

_SettlementWhereUnique_code_Input = TypedDict(
    '_SettlementWhereUnique_code_Input',
    {
        'code': '_int',
    },
    total=True
)

SettlementWhereUniqueInput = Union[
    '_SettlementWhereUnique_id_Input',
    '_SettlementWhereUnique_code_Input',
]


class SettlementUpdateInput(TypedDict, total=False):
    """Optional arguments for updating a record"""
    id: Union[AtomicIntInput, _int]
    code: Union[AtomicIntInput, _int]
    name: _str
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]
    userAnswers: 'UserAnswerNewUpdateManyWithoutRelationsInput'


class SettlementUpdateManyMutationInput(TypedDict, total=False):
    """Arguments for updating many records"""
    id: Union[AtomicIntInput, _int]
    code: Union[AtomicIntInput, _int]
    name: _str
    alias1: Optional[_str]
    alias2: Optional[_str]
    alias3: Optional[_str]


class SettlementUpdateManyWithoutRelationsInput(TypedDict, total=False):
    create: List['SettlementCreateWithoutRelationsInput']
    connect: List['SettlementWhereUniqueInput']
    set: List['SettlementWhereUniqueInput']
    disconnect: List['SettlementWhereUniqueInput']
    delete: List['SettlementWhereUniqueInput']

    # TODO
    # update: List['SettlementUpdateWithWhereUniqueWithoutRelationsInput']
    # updateMany: List['SettlementUpdateManyWithWhereUniqueWithoutRelationsInput']
    # deleteMany: List['SettlementScalarWhereInput']
    # upsert: List['SettlementUpserteWithWhereUniqueWithoutRelationsInput']
    # connectOrCreate: List['SettlementCreateOrConnectWithoutRelationsInput']


class SettlementUpdateOneWithoutRelationsInput(TypedDict, total=False):
    create: 'SettlementCreateWithoutRelationsInput'
    connect: 'SettlementWhereUniqueInput'
    disconnect: bool
    delete: bool

    # TODO
    # update: 'SettlementUpdateInput'
    # upsert: 'SettlementUpsertWithoutRelationsInput'
    # connectOrCreate: 'SettlementCreateOrConnectWithoutRelationsInput'


class SettlementUpsertInput(TypedDict):
    create: 'SettlementCreateInput'
    update: 'SettlementUpdateInput'  # pyright: ignore[reportIncompatibleMethodOverride]


_Settlement_id_OrderByInput = TypedDict(
    '_Settlement_id_OrderByInput',
    {
        'id': 'SortOrder',
    },
    total=True
)

_Settlement_code_OrderByInput = TypedDict(
    '_Settlement_code_OrderByInput',
    {
        'code': 'SortOrder',
    },
    total=True
)

_Settlement_name_OrderByInput = TypedDict(
    '_Settlement_name_OrderByInput',
    {
        'name': 'SortOrder',
    },
    total=True
)

_Settlement_alias1_OrderByInput = TypedDict(
    '_Settlement_alias1_OrderByInput',
    {
        'alias1': 'SortOrder',
    },
    total=True
)

_Settlement_alias2_OrderByInput = TypedDict(
    '_Settlement_alias2_OrderByInput',
    {
        'alias2': 'SortOrder',
    },
    total=True
)

_Settlement_alias3_OrderByInput = TypedDict(
    '_Settlement_alias3_OrderByInput',
    {
        'alias3': 'SortOrder',
    },
    total=True
)

SettlementOrderByInput = Union[
    '_Settlement_id_OrderByInput',
    '_Settlement_code_OrderByInput',
    '_Settlement_name_OrderByInput',
    '_Settlement_alias1_OrderByInput',
    '_Settlement_alias2_OrderByInput',
    '_Settlement_alias3_OrderByInput',
]



# recursive Settlement types
# TODO: cleanup these types


# Dict[str, Any] is a mypy limitation
# see https://github.com/RobertCraigie/prisma-client-py/issues/45
# switch to pyright for improved types, see https://prisma-client-py.readthedocs.io/en/stable/reference/limitations/

SettlementRelationFilter = TypedDict(
    'SettlementRelationFilter',
    {
        'is': 'Dict[str, Any]',
        'is_not': 'Dict[str, Any]',
    },
    total=False,
)


class SettlementListRelationFilter(TypedDict, total=False):
    some: 'Dict[str, Any]'
    none: 'Dict[str, Any]'
    every: 'Dict[str, Any]'


class SettlementInclude(TypedDict, total=False):
    """Settlement relational arguments"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSettlement']


    

class SurveyIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    questions: Union[bool, 'FindManyQuestionArgsFromSettlementRecursive1']


class SurveyIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    questions: Union[bool, 'FindManyQuestionArgsFromSettlementRecursive2']


class SurveyIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    questions: Union[bool, 'FindManyQuestionArgsFromSettlementRecursive3']


class SurveyIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    questions: Union[bool, 'FindManyQuestionArgsFromSettlementRecursive4']


class SurveyIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class SurveyArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SurveyIncludeFromSurveyRecursive1'


class SurveyArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SurveyIncludeFromSurveyRecursive2'


class SurveyArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SurveyIncludeFromSurveyRecursive3'


class SurveyArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SurveyIncludeFromSurveyRecursive4'


class SurveyArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManySurveyArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive1'


class FindManySurveyArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive2'


class FindManySurveyArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive3'


class FindManySurveyArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    include: 'SurveyIncludeFromSurveyRecursive4'


class FindManySurveyArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SurveyOrderByInput', List['SurveyOrderByInput']]
    where: 'SurveyWhereInput'
    cursor: 'SurveyWhereUniqueInput'
    distinct: List['SurveyScalarFieldKeys']
    
    

class QuestionIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    survey: Union[bool, 'SurveyArgsFromSettlementRecursive1']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive1']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive1']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive1']


class QuestionIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    survey: Union[bool, 'SurveyArgsFromSettlementRecursive2']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive2']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive2']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive2']


class QuestionIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    survey: Union[bool, 'SurveyArgsFromSettlementRecursive3']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive3']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive3']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive3']


class QuestionIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    survey: Union[bool, 'SurveyArgsFromSettlementRecursive4']
    optionalAnswers: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive4']
    userAnswers: Union[bool, 'FindManyUserAnswerArgsFromSettlementRecursive4']
    followingQuestions: Union[bool, 'FindManyOptionalAnswerArgsFromSettlementRecursive4']


class QuestionIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class QuestionArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'QuestionIncludeFromQuestionRecursive1'


class QuestionArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'QuestionIncludeFromQuestionRecursive2'


class QuestionArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'QuestionIncludeFromQuestionRecursive3'


class QuestionArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'QuestionIncludeFromQuestionRecursive4'


class QuestionArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManyQuestionArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive1'


class FindManyQuestionArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive2'


class FindManyQuestionArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive3'


class FindManyQuestionArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    include: 'QuestionIncludeFromQuestionRecursive4'


class FindManyQuestionArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['QuestionOrderByInput', List['QuestionOrderByInput']]
    where: 'QuestionWhereInput'
    cursor: 'QuestionWhereUniqueInput'
    distinct: List['QuestionScalarFieldKeys']
    
    

class OptionalAnswerIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive1']
    followingQuestion: Union[bool, 'QuestionArgsFromSettlementRecursive1']


class OptionalAnswerIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive2']
    followingQuestion: Union[bool, 'QuestionArgsFromSettlementRecursive2']


class OptionalAnswerIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive3']
    followingQuestion: Union[bool, 'QuestionArgsFromSettlementRecursive3']


class OptionalAnswerIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive4']
    followingQuestion: Union[bool, 'QuestionArgsFromSettlementRecursive4']


class OptionalAnswerIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class OptionalAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class OptionalAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class OptionalAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class OptionalAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class OptionalAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManyOptionalAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive1'


class FindManyOptionalAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive2'


class FindManyOptionalAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive3'


class FindManyOptionalAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    include: 'OptionalAnswerIncludeFromOptionalAnswerRecursive4'


class FindManyOptionalAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['OptionalAnswerOrderByInput', List['OptionalAnswerOrderByInput']]
    where: 'OptionalAnswerWhereInput'
    cursor: 'OptionalAnswerWhereUniqueInput'
    distinct: List['OptionalAnswerScalarFieldKeys']
    
    

class UserAnswerIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive1']


class UserAnswerIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive2']


class UserAnswerIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive3']


class UserAnswerIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    question: Union[bool, 'QuestionArgsFromSettlementRecursive4']


class UserAnswerIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class UserAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class UserAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class UserAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class UserAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class UserAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManyUserAnswerArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive1'


class FindManyUserAnswerArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive2'


class FindManyUserAnswerArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive3'


class FindManyUserAnswerArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    include: 'UserAnswerIncludeFromUserAnswerRecursive4'


class FindManyUserAnswerArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerOrderByInput', List['UserAnswerOrderByInput']]
    where: 'UserAnswerWhereInput'
    cursor: 'UserAnswerWhereUniqueInput'
    distinct: List['UserAnswerScalarFieldKeys']
    
    

class UserAnswerNewIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive1']


class UserAnswerNewIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive2']


class UserAnswerNewIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive3']


class UserAnswerNewIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    settlement: Union[bool, 'SettlementArgsFromSettlementRecursive4']


class UserAnswerNewIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class UserAnswerNewArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class UserAnswerNewArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class UserAnswerNewArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class UserAnswerNewArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class UserAnswerNewArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManyUserAnswerNewArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive1'


class FindManyUserAnswerNewArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive2'


class FindManyUserAnswerNewArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive3'


class FindManyUserAnswerNewArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    include: 'UserAnswerNewIncludeFromUserAnswerNewRecursive4'


class FindManyUserAnswerNewArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['UserAnswerNewOrderByInput', List['UserAnswerNewOrderByInput']]
    where: 'UserAnswerNewWhereInput'
    cursor: 'UserAnswerNewWhereUniqueInput'
    distinct: List['UserAnswerNewScalarFieldKeys']
    
    

class SettlementIncludeFromSettlement(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSettlementRecursive1']


class SettlementIncludeFromSettlementRecursive1(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSettlementRecursive2']


class SettlementIncludeFromSettlementRecursive2(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSettlementRecursive3']


class SettlementIncludeFromSettlementRecursive3(TypedDict, total=False):
    """Relational arguments for Settlement"""
    userAnswers: Union[bool, 'FindManyUserAnswerNewArgsFromSettlementRecursive4']


class SettlementIncludeFromSettlementRecursive4(TypedDict, total=False):
    """Relational arguments for Settlement"""

    

class SettlementArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive1'


class SettlementArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive2'


class SettlementArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive3'


class SettlementArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    include: 'SettlementIncludeFromSettlementRecursive4'


class SettlementArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    
    

class FindManySettlementArgsFromSettlement(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive1'


class FindManySettlementArgsFromSettlementRecursive1(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive2'


class FindManySettlementArgsFromSettlementRecursive2(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive3'


class FindManySettlementArgsFromSettlementRecursive3(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    include: 'SettlementIncludeFromSettlementRecursive4'


class FindManySettlementArgsFromSettlementRecursive4(TypedDict, total=False):
    """Arguments for Settlement"""
    take: int
    skip: int
    order_by: Union['SettlementOrderByInput', List['SettlementOrderByInput']]
    where: 'SettlementWhereInput'
    cursor: 'SettlementWhereUniqueInput'
    distinct: List['SettlementScalarFieldKeys']
    


FindManySettlementArgs = FindManySettlementArgsFromSettlement
FindFirstSettlementArgs = FindManySettlementArgsFromSettlement


    

class SettlementWhereInput(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerNewListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive1', List['SettlementWhereInputRecursive1']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive1']
    OR: List['SettlementWhereInputRecursive1']
    NOT: List['SettlementWhereInputRecursive1']


class SettlementWhereInputRecursive1(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerNewListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive2', List['SettlementWhereInputRecursive2']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive2']
    OR: List['SettlementWhereInputRecursive2']
    NOT: List['SettlementWhereInputRecursive2']


class SettlementWhereInputRecursive2(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerNewListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive3', List['SettlementWhereInputRecursive3']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive3']
    OR: List['SettlementWhereInputRecursive3']
    NOT: List['SettlementWhereInputRecursive3']


class SettlementWhereInputRecursive3(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerNewListRelationFilter'

    # should be noted that AND and NOT should be Union['SettlementWhereInputRecursive4', List['SettlementWhereInputRecursive4']]
    # but this causes mypy to hang :/
    AND: List['SettlementWhereInputRecursive4']
    OR: List['SettlementWhereInputRecursive4']
    NOT: List['SettlementWhereInputRecursive4']


class SettlementWhereInputRecursive4(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntFilter']
    code: Union[_int, 'types.IntFilter']
    name: Union[_str, 'types.StringFilter']
    alias1: Union[None, _str, 'types.StringFilter']
    alias2: Union[None, _str, 'types.StringFilter']
    alias3: Union[None, _str, 'types.StringFilter']
    userAnswers: 'UserAnswerNewListRelationFilter'



# aggregate Settlement types


    

class SettlementScalarWhereWithAggregatesInput(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive1']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive1']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive1']


class SettlementScalarWhereWithAggregatesInputRecursive1(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive2']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive2']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive2']


class SettlementScalarWhereWithAggregatesInputRecursive2(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive3']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive3']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive3']


class SettlementScalarWhereWithAggregatesInputRecursive3(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']

    AND: List['SettlementScalarWhereWithAggregatesInputRecursive4']
    OR: List['SettlementScalarWhereWithAggregatesInputRecursive4']
    NOT: List['SettlementScalarWhereWithAggregatesInputRecursive4']


class SettlementScalarWhereWithAggregatesInputRecursive4(TypedDict, total=False):
    """Settlement arguments for searching"""
    id: Union[_int, 'types.IntWithAggregatesFilter']
    code: Union[_int, 'types.IntWithAggregatesFilter']
    name: Union[_str, 'types.StringWithAggregatesFilter']
    alias1: Union[_str, 'types.StringWithAggregatesFilter']
    alias2: Union[_str, 'types.StringWithAggregatesFilter']
    alias3: Union[_str, 'types.StringWithAggregatesFilter']



class SettlementGroupByOutput(TypedDict, total=False):
    id: _int
    code: _int
    name: _str
    alias1: _str
    alias2: _str
    alias3: _str
    _sum: 'SettlementSumAggregateOutput'
    _avg: 'SettlementAvgAggregateOutput'
    _min: 'SettlementMinAggregateOutput'
    _max: 'SettlementMaxAggregateOutput'
    _count: 'SettlementCountAggregateOutput'


class SettlementAvgAggregateOutput(TypedDict, total=False):
    """Settlement output for aggregating averages"""
    id: float
    code: float


class SettlementSumAggregateOutput(TypedDict, total=False):
    """Settlement output for aggregating sums"""
    id: _int
    code: _int


class SettlementScalarAggregateOutput(TypedDict, total=False):
    """Settlement output including scalar fields"""
    id: _int
    code: _int
    name: _str
    alias1: _str
    alias2: _str
    alias3: _str


SettlementMinAggregateOutput = SettlementScalarAggregateOutput
SettlementMaxAggregateOutput = SettlementScalarAggregateOutput


class SettlementMaxAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating by max"""
    id: bool
    code: bool
    name: bool
    alias1: bool
    alias2: bool
    alias3: bool


class SettlementMinAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating by min"""
    id: bool
    code: bool
    name: bool
    alias1: bool
    alias2: bool
    alias3: bool


class SettlementNumberAggregateInput(TypedDict, total=False):
    """Settlement input for aggregating numbers"""
    id: bool
    code: bool


SettlementAvgAggregateInput = SettlementNumberAggregateInput
SettlementSumAggregateInput = SettlementNumberAggregateInput


SettlementCountAggregateInput = TypedDict(
    'SettlementCountAggregateInput',
    {
        'id': bool,
        'code': bool,
        'name': bool,
        'alias1': bool,
        'alias2': bool,
        'alias3': bool,
        '_all': bool,
    },
    total=False,
)

SettlementCountAggregateOutput = TypedDict(
    'SettlementCountAggregateOutput',
    {
        'id': int,
        'code': int,
        'name': int,
        'alias1': int,
        'alias2': int,
        'alias3': int,
        '_all': int,
    },
    total=False,
)


SettlementKeys = Literal[
    'id',
    'code',
    'name',
    'alias1',
    'alias2',
    'alias3',
    'userAnswers',
]
SettlementScalarFieldKeys = Literal[
    'id',
    'code',
    'name',
    'alias1',
    'alias2',
    'alias3',
]
SettlementScalarFieldKeysT = TypeVar('SettlementScalarFieldKeysT', bound=SettlementScalarFieldKeys)

SettlementRelationalFieldKeys = Literal[
        'userAnswers',
    ]



# we have to import ourselves as types can be namespaced to types
from . import types, enums, models, fields